<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>memory detail | Ya!</title><link>https://wooya.me/tags/memory-detail/</link><atom:link href="https://wooya.me/tags/memory-detail/index.xml" rel="self" type="application/rss+xml"/><description>memory detail</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>© 2020 Weiyuan</copyright><lastBuildDate>Wed, 04 Nov 2015 11:51:39 +0800</lastBuildDate><image><url>https://wooya.me/media/icon.png</url><title>memory detail</title><link>https://wooya.me/tags/memory-detail/</link></image><item><title>Rust Enum</title><link>https://wooya.me/post/rust-enum/</link><pubDate>Wed, 04 Nov 2015 11:51:39 +0800</pubDate><guid>https://wooya.me/post/rust-enum/</guid><description>&lt;p>本文通过解析&lt;code>llvm&lt;/code>的&lt;code>ir&lt;/code>来解析rust &lt;code>enum&lt;/code>的内存布局。&lt;/p>
&lt;p>rust的enum差不多是C的&lt;code>enum&lt;/code>和&lt;code>union&lt;/code>类型的混合体。可以写成&lt;/p>
&lt;pre>&lt;code class="language-rust">enum Enum {
AEnum = 0,
BEnum = 1,
CEnum = 2,
} // 类似C的Enum
&lt;/code>&lt;/pre>
&lt;p>也可以&lt;/p>
&lt;pre>&lt;code class="language-rust"> enum Buk {
two_int(int,int),
three_uint(uint,uint,uint),
lonely_f64(f64),
} // 类似union
&lt;/code>&lt;/pre>
&lt;p>甚至&lt;/p>
&lt;pre>&lt;code class="language-rust">enum LinkedListNode&amp;lt;T&amp;gt; {
DataOnly(T),
DataWithNext(T,Box&amp;lt;LinkedListNode&amp;lt;T&amp;gt;&amp;gt;),
}
&lt;/code>&lt;/pre>
&lt;p>总之，利用rust的enum，可以任意的构造想要的抽象数据结构。
在另一些语言中，这种数据结构叫做ADT(algebra data type, 代数数据类型)。&lt;/p>
&lt;p>===============================================&lt;/p>
&lt;ul>
&lt;li>最普通的enum。&lt;/li>
&lt;/ul>
&lt;p>有如下结构：&lt;/p>
&lt;pre>&lt;code class="language-rust">enum simple {
A,B,C,D
}
&lt;/code>&lt;/pre>
&lt;p>在rust编译完以后，完全不会为simple生成任何的数据结构。
&lt;code>let a = A&lt;/code> 只会被rust编译成 &lt;code>let a: i8 = 0&lt;/code>。同理，B就是1i8，C就是2i8.&lt;/p>
&lt;p>同理&lt;/p>
&lt;pre>&lt;code class="language-rust">enum simple {
A = 1,
B = 2,
C = 3,
D = 4,
}
&lt;/code>&lt;/pre>
&lt;p>也只是把&lt;code>let a = 0i8&lt;/code>变成了&lt;code>let a = 1i8&lt;/code>而已。&lt;/p>
&lt;p>match这样一个最简单的enum，rust所做的仅仅只有一个简单的对i8的switch语句。&lt;/p>
&lt;ul>
&lt;li>union like enum&lt;/li>
&lt;/ul>
&lt;p>考虑如下enum：&lt;/p>
&lt;pre>&lt;code class="language-rust">enum simple {
A(i32,i64),
B(u8),
C(f32),
}
&lt;/code>&lt;/pre>
&lt;p>这时，这个enum的llvm内存表示为&lt;code>{ i8, [7 x i8], [1 x i64] }&lt;/code>，用rust来表示就是&lt;code>(i8,i8,i8,i8,i8,i8,i8,i8,i64)&lt;/code>&lt;/p>
&lt;p>一共8个i8，一个i64.
可能会纳闷：怎么会有那么多i8呢？
原因在于：内存对齐。&lt;/p>
&lt;p>首先，enum的标号肯定位于头部，就是第一个i8.因此A还是0，B还是1.
但是和例1不同的是，本例中的enum是带有自定义数据的。所以必须为自定义数据分配空间。
我们来算一下：一共需要1&lt;em>i8（用于标号）+1&lt;/em>i32（A的第一个域）+1&lt;em>64（A的第二个域）。B和C我们就不管了，因为它们的大小都小于A，因此我们可以复用A的内存空间。所以这样一个enum至少需要104个bit。但是由于内存对齐的原因，第一个i8要和后面的i64对齐，所以要补上7个i8，因为7&lt;/em>8+8=64嘛。
补完之后我们发现，那个i32也可以被用来补完的7个i8来表示了（4个i8凑一凑就一个i32了嘛）。于是这个enum就是8个i8+1个i64组成了。&lt;/p>
&lt;p>现在来看看当它们分别是A，B，C时的情况。
当enum是A的时候，它的结构会转换成{i8, i32,
i64}.第一个用于标号，是0.第二个是A的第一个域，i32，i64是第二个域。用于内存对齐的i8被llvm自动藏起来了。完整的表示是{i8,
[3 x i8], i32, i64}，中间3个i8会隐藏掉。
当enum是B的时候，结构就变成了{i8,i8}后面的一大堆东西统统不要。所以如果一个enum要是被这样构造了，每一个B都会浪费大量的空间（空间使用率16/128=12.5%）。对于单片机编程来说要尽量避免这种情况。
当enum是C的时候，结构是{i8,float},[3xi8]同A，会隐藏起来。后面浪费了一个i64.利用率50%，也挺低。&lt;/p>
&lt;ul>
&lt;li>1和2混搭&lt;/li>
&lt;/ul>
&lt;p>如下enum：&lt;/p>
&lt;pre>&lt;code class="language-rust">enum simple {
A(i32,i64),
B(u8),
C(f32),
D,
E
}
&lt;/code>&lt;/pre>
&lt;p>具体情况和union enum差不多。后面两个D和E变成{i8}罢了。&lt;/p>
&lt;ul>
&lt;li>泛型enum&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-rust"> enum simple&amp;lt;T&amp;gt; {
Data(T),
Nil
}
let a = simple::Data::&amp;lt;int&amp;gt;(1);
let b = simple::Nil::&amp;lt;uint&amp;gt;;
&lt;/code>&lt;/pre>
&lt;p>泛型其实只是生成了两份代码，一个叫&lt;code>%&amp;quot;enum.main::simple&amp;lt;[int]&amp;gt;&amp;quot; = type { i8, [7 x i8], [1 x i64] }&lt;/code>，
另一个叫&lt;code>%&amp;quot;enum.main::simple&amp;lt;[uint]&amp;gt;&amp;quot; = type { i8, [7 x i8], [1 x i64] }&lt;/code>，其它无任何差别。&lt;/p>
&lt;ul>
&lt;li>struct variant&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-rust">enum simple {
duck {a: int, b: int},
Nil
}
let a = simple::duck{a:4,b:3};
&lt;/code>&lt;/pre>
&lt;p>和普通的enum一样，只是给duck里面的两个i64起个名字罢了。在ir层面没有任何区别。&lt;/p>
&lt;ul>
&lt;li>#[repr(C)]&lt;/li>
&lt;/ul>
&lt;p>rust还支持把enum的内存表示变为C风格的。&lt;/p>
&lt;pre>&lt;code class="language-rust">#[repr(C)]
enum simple {
a(int),
b,c
}
&lt;/code>&lt;/pre>
&lt;p>这儿的区别在于，头部的标号和内存对齐，全部从i8变成了i32，即C的int。&lt;code>{i32, [1 x i32], i64}&lt;/code>&lt;/p></description></item></channel></rss>