<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>rust | IRIS</title><link>http://wooya.me/categories/rust/</link><atom:link href="http://wooya.me/categories/rust/index.xml" rel="self" type="application/rss+xml"/><description>rust</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>© 2019 Weiyüen</copyright><lastBuildDate>Wed, 04 Nov 2015 11:54:16 +0800</lastBuildDate><image><url>http://wooya.me/img/icon.png</url><title>rust</title><link>http://wooya.me/categories/rust/</link></image><item><title>Rust Compiler Plugin</title><link>http://wooya.me/post/rust-compiler-plugin/</link><pubDate>Wed, 04 Nov 2015 11:54:16 +0800</pubDate><guid>http://wooya.me/post/rust-compiler-plugin/</guid><description>&lt;p>rust 提供了一个很强大的编译时功能：自定义编译器插件。&lt;/p>
&lt;p>通过向编译器register一个函数作为入口，它可以在lint时期把ast作为register的那个函数的一个参数来invoke。也就是说，通过编译器插件，我们可以做很多强（wei）大（suo）的事情。&lt;/p>
&lt;ul>
&lt;li>例子1：
&lt;a href="https://github.com/brson/rust-chamber" target="_blank" rel="noopener">rust-chamber&lt;/a>
&lt;/li>
&lt;/ul>
&lt;p>chamber是一个语言级别的sandbox(其实是一个rustc的包装)，可以防止你的语言中出现不安全的code。目前它的功能很简单，一旦发现你的code里面有使用了unsafe，或者开启了编译器feature(#![feature()]),
或者使用了不安全的crate（比如intrinsic）编译就会通不过。怎么实现的呢？其实很简单。下面贴上核心代码：&lt;/p>
&lt;!--more-->
&lt;pre>&lt;code class="language-rust">fn check_expr(&amp;amp;mut self, ctx: &amp;amp;Context, e: &amp;amp;ast::Expr) {
match e.node {
// Don't warn about generated blocks, that'll just pollute the output.
ast::ExprBlock(ref blk) if blk.rules == ast::UnsafeBlock(ast::UserProvided) =&amp;gt; {
ctx.span_lint(CH_UNSAFE_BLOCK, e.span, &amp;quot;chamber: `unsafe` block&amp;quot;);
}
_ =&amp;gt; ()
}
}
&lt;/code>&lt;/pre>
&lt;p>context是用来控制编译器行为的。e是传入的expression的ast表现形式。check_expr的作用就是对每个传入的expression进行判断，如果是unsafe
block，就报错。&lt;/p>
&lt;ul>
&lt;li>例子2：
&lt;a href="https://github.com/huonw/spellck" target="_blank" rel="noopener">spellck&lt;/a>
&lt;/li>
&lt;/ul>
&lt;p>这是一个基于字典的拼写检查插件。通过字典，可以将代码中的单词拼写错误在编译器进行提示。麻麻再也不用担心我在代码里面打错别字啦！&lt;/p>
&lt;ul>
&lt;li>例子3：
&lt;a href="http://static.rust-lang.org/doc/master/regex/index.html" target="_blank" rel="noopener">regex&lt;/a>
&lt;/li>
&lt;/ul>
&lt;p>重量级插件：rust官方正则表达式库。什么？正则表达式和插件有什么关系？
这里说的是rust的regex！宏。众所周知，正则表达式需要进行编译。比如python的re.compile，go的regexp.Compile等等。正则表达式需要在运行时，将一个正则表达式字符串编译成正则表达式虚拟机上的指令。所以正则表达式其实是一个内嵌在语言内部的虚拟机语言。
既然正则表达式在运行时才能够进行编译，并且只是编译成虚拟机指令，那么它的效率必然会比原生代码低很多。那么我们能不能把这个过程提前到编译时呢？正则表达式规则是通过字符串的形式来书写的，在编译时无法确定它的内容（字符串是可变的）。所以在一般的语言中确实做不到编译时处理正则表达式。但是通过rust的编译器插件，我们可以实现对常量字符串表达式进行编译时的正则表达式编译。
regex插件在编译时会把相应的正则表达式编译成rust代码，所以在运行时完全没有用到正则的虚拟机和指令。因此执行速度非常快。但唯一的缺点就是如果生成太多的正则表达式，那么编译出来的二进制文件会变得非常大。（毕竟是吧正则表达式展开成了大量的rust代码。）&lt;/p>
&lt;p>================================================================&lt;/p>
&lt;p>介绍到此为止，下面是教程。
首先，你需要引入一个编译器特性， &lt;code>plugin_registrar&lt;/code>
在代码开头加上
&lt;code>#![feature(phase, plugin_registrar)]&lt;/code>
使用phase特性是因为我们需要一些在rustc里面的宏来帮忙。可以省去一些代码。&lt;/p>
&lt;pre>&lt;code>#[phase(plugin, link)] // Load rustc as a plugin to get lint macros
extern crate rustc;
extern crate syntax;
use rustc::lint::{Context, LintPass, LintArray};
use rustc::plugin::Registry;
use syntax::ast;
&lt;/code>&lt;/pre>
&lt;p>引入一些crate。
phase是一个编译器特性。其中plugin的意思是把crate当作插件插入到当前代码（为了引入其中的macro。因为macro不能像传统变量那样采用use来引入），link的意思是把该crate连接到此文件（crate默认其实有一个link的feature）。
接下来是建立一个lint的属性：&lt;/p>
&lt;pre>&lt;code>pub static mylint: &amp;amp;'static rustc::lint::Lint = &amp;amp;lint_initializer!(mylint, Deny, &amp;quot;abrakadabra&amp;quot;);
&lt;/code>&lt;/pre>
&lt;p>我们把它起名字叫做mylint。默认级别是Deny,
并且把它绑定到了mylint这个static变量上（需要注意的是，Lint变量必须是static的）。描述随便写了点。
其中，lint的级别有四个，分别是Allow,Warn,Deny,Forbid.其中Forbid和Deny的区别在于，如果是Deny，那么在源代码里面，使用者可以通过#[allow(myliny)],#[warn(mylint)]进行lint级别更换。比如从禁止一个特性转变为只是警告（P.S.
那就没用啦！程序员从来不看警告）。但是如果设置为Forbid级别，那么用户就无论如何也没办法改变你的lint级别了。比如上面的例子，chamber里面，作者就使用了Forbid级别。
然后我们新建一个LintPassObject;&lt;/p>
&lt;pre>&lt;code>struct MyLintPass1;
&lt;/code>&lt;/pre>
&lt;p>要成为一个LintPassObject，还需要一个Trait的帮助。&lt;/p>
&lt;pre>&lt;code>impl LintPass for MyLintPass1 {
fn get_lints(&amp;amp;self) -&amp;gt; LintArray {
lint_array!(mylint)
}
}
&lt;/code>&lt;/pre>
&lt;p>我们需要为我们的LintPassObject实现LintPass这个Trait。
LintPass这个Trait有很多方法，但是我们只要实现get_lint这一个就可以了。&lt;code>get_lint&lt;/code>这个方法的含义就是把我们前面建立的那个&lt;code>mylint&lt;/code>这个&lt;code>lint&lt;/code>和我们的&lt;code>LintPassObject&lt;/code>关联起来。&lt;code>lint_array&lt;/code>这个宏的作用就是生成一个&lt;code>static&lt;/code>的&lt;code>lint array&lt;/code>。
然后，最后一件事，就是把我们的&lt;code>LintPassObject&lt;/code>注册进编译器。&lt;/p>
&lt;pre>&lt;code>#[plugin_registrar]
pub fn plugin_registrar(reg: &amp;amp;mut Registry) {
reg.register_lint_pass(box MyLintPass1);
}
&lt;/code>&lt;/pre>
&lt;p>只要在一个函数上面打上&lt;/p>
&lt;pre>&lt;code>#[plugin_registrar]
&lt;/code>&lt;/pre>
&lt;p>就告诉了编译器，下面那个函数，是要cha进你身体里的！
然后我们就完成了一个最简单的编译器插件。把它编译成dylib（注意必须是动态链接库，不能编译成rlib）
在需要使用它的地方写上&lt;/p>
&lt;pre>&lt;code>#![feature(phase)]
#[phase(plugin)] extern crate plugin;
&lt;/code>&lt;/pre>
&lt;p>就ok啦！
于是我们完成了一个什么都不做的编译器插件。&lt;/p>
&lt;p>接下来我们给我们的插件添加点小功能：阻止编译啊哈哈哈！
在这个地方，我们加一个函数实现&lt;/p>
&lt;pre>&lt;code>impl LintPass for MyLintPass1 {
fn get_lints(&amp;amp;self) -&amp;gt; LintArray {
lint_array!(mylint)
}
fn check_crate(&amp;amp;mut self, ctx: &amp;amp;Context, crt: &amp;amp;ast::Crate) {
ctx.lint(mylint, &amp;quot;deliberate fail!&amp;quot;)
}
}
&lt;/code>&lt;/pre>
&lt;p>于是除非你在main函数打标记#[allow(mylint)]否则编译就是通不过啦啦啦&lt;/p></description></item><item><title>Rust Inline ASM</title><link>http://wooya.me/post/rust-inline-asm/</link><pubDate>Wed, 04 Nov 2015 11:53:30 +0800</pubDate><guid>http://wooya.me/post/rust-inline-asm/</guid><description>&lt;p>rust和c/c++一样,可以内联汇编.语法和c/c++的内联汇编大致一样.只有几个细节稍有不同.&lt;/p>
&lt;p>首先,需要开启一个特性 &lt;code>#![feature(asm)]&lt;/code>&lt;/p>
&lt;p>然后在&lt;code>asm!&lt;/code>宏里面写汇编即可.&lt;/p>
&lt;p>格式是:&lt;/p>
&lt;pre>&lt;code>asm!(assembly template
: output operands
: input operands
: clobbers
: options
);
&lt;/code>&lt;/pre>
&lt;p>大致和c/c++相同.其中有几个不同点:&lt;/p>
&lt;p>在最后一段用来声明已经使用过的寄存器的那一段(clobbers)下面还可以跟一段option段.备选项有:&amp;ldquo;intel&amp;quot;表示采用intel汇编而不像c那样用AT&amp;amp;T汇编.&amp;ldquo;volatile&amp;rdquo;,和c里面的&lt;code>__asm__volatile__&lt;/code>一样.&amp;ldquo;alignstack&amp;rdquo;,让编译器自动插入对齐栈的代码(因为有些指令集需要对齐栈,比如SSE指令集).
在填充模版的时候,变量用$0,$1来表示,而不是c的%1,%2来表示.
立即数用&lt;code>$$&lt;/code>表示,&lt;code>$$1&lt;/code>就是1.
寄存器直接用%来表示,%eax表示eax寄存器
模版里面多条指令用分号(;)来分割,而不是c的&amp;rdquo;\r\n&amp;rdquo;
声明clobber的时候直接写&lt;code>eax&lt;/code>,不用像C那样写&lt;code>%eax&lt;/code>
记得&lt;code>asm!&lt;/code>的时候要外面套&lt;code>unsafe&lt;/code>块
intel语法我没有试过.所以无从比较语法区别:(&lt;/p>
&lt;p>下面附上我的一个小例子,用汇编+偏移量来访问数组.&lt;/p>
&lt;pre>&lt;code class="language-rust">#![feature(asm)]
fn main() {asm();}
#[cfg(target_arch = &amp;quot;x86_64&amp;quot;)]
fn asm() {
use std::mem::transmute;
use std::rand::random;
let array: &amp;amp;[u64] = &amp;amp;[random(),random(),random(),random()];
let address = unsafe { transmute::&amp;lt;_, (i64, i64)&amp;gt;(array).0 };
for offset in 0u64..4 {
let ret: u64;
unsafe {
asm!(
r&amp;quot;
mov ($1, $2, 8), %rax;
mov %rax, $0;
&amp;quot;
: &amp;quot;=r&amp;quot;(ret)
: &amp;quot;r&amp;quot;(address), &amp;quot;r&amp;quot;(offset)
: &amp;quot;rax&amp;quot;
:
);
}
println!(&amp;quot;在第{}号位上的元素是{}&amp;quot;, offset, ret);
}
}
&lt;/code>&lt;/pre></description></item><item><title>Rust Enum</title><link>http://wooya.me/post/rust-enum/</link><pubDate>Wed, 04 Nov 2015 11:51:39 +0800</pubDate><guid>http://wooya.me/post/rust-enum/</guid><description>&lt;p>本文通过解析&lt;code>llvm&lt;/code>的&lt;code>ir&lt;/code>来解析rust &lt;code>enum&lt;/code>的内存布局。&lt;/p>
&lt;p>rust的enum差不多是C的&lt;code>enum&lt;/code>和&lt;code>union&lt;/code>类型的混合体。可以写成&lt;/p>
&lt;pre>&lt;code class="language-rust">enum Enum {
AEnum = 0,
BEnum = 1,
CEnum = 2,
} // 类似C的Enum
&lt;/code>&lt;/pre>
&lt;p>也可以&lt;/p>
&lt;pre>&lt;code class="language-rust"> enum Buk {
two_int(int,int),
three_uint(uint,uint,uint),
lonely_f64(f64),
} // 类似union
&lt;/code>&lt;/pre>
&lt;p>甚至&lt;/p>
&lt;pre>&lt;code class="language-rust">enum LinkedListNode&amp;lt;T&amp;gt; {
DataOnly(T),
DataWithNext(T,Box&amp;lt;LinkedListNode&amp;lt;T&amp;gt;&amp;gt;),
}
&lt;/code>&lt;/pre>
&lt;p>总之，利用rust的enum，可以任意的构造想要的抽象数据结构。
在另一些语言中，这种数据结构叫做ADT(algebra data type, 代数数据类型)。&lt;/p>
&lt;p>===============================================&lt;/p>
&lt;ul>
&lt;li>最普通的enum。&lt;/li>
&lt;/ul>
&lt;p>有如下结构：&lt;/p>
&lt;pre>&lt;code class="language-rust">enum simple {
A,B,C,D
}
&lt;/code>&lt;/pre>
&lt;p>在rust编译完以后，完全不会为simple生成任何的数据结构。
&lt;code>let a = A&lt;/code> 只会被rust编译成 &lt;code>let a: i8 = 0&lt;/code>。同理，B就是1i8，C就是2i8.&lt;/p>
&lt;p>同理&lt;/p>
&lt;pre>&lt;code class="language-rust">enum simple {
A = 1,
B = 2,
C = 3,
D = 4,
}
&lt;/code>&lt;/pre>
&lt;p>也只是把&lt;code>let a = 0i8&lt;/code>变成了&lt;code>let a = 1i8&lt;/code>而已。&lt;/p>
&lt;p>match这样一个最简单的enum，rust所做的仅仅只有一个简单的对i8的switch语句。&lt;/p>
&lt;ul>
&lt;li>union like enum&lt;/li>
&lt;/ul>
&lt;p>考虑如下enum：&lt;/p>
&lt;pre>&lt;code class="language-rust">enum simple {
A(i32,i64),
B(u8),
C(f32),
}
&lt;/code>&lt;/pre>
&lt;p>这时，这个enum的llvm内存表示为&lt;code>{ i8, [7 x i8], [1 x i64] }&lt;/code>，用rust来表示就是&lt;code>(i8,i8,i8,i8,i8,i8,i8,i8,i64)&lt;/code>&lt;/p>
&lt;p>一共8个i8，一个i64.
可能会纳闷：怎么会有那么多i8呢？
原因在于：内存对齐。&lt;/p>
&lt;p>首先，enum的标号肯定位于头部，就是第一个i8.因此A还是0，B还是1.
但是和例1不同的是，本例中的enum是带有自定义数据的。所以必须为自定义数据分配空间。
我们来算一下：一共需要1&lt;em>i8（用于标号）+1&lt;/em>i32（A的第一个域）+1&lt;em>64（A的第二个域）。B和C我们就不管了，因为它们的大小都小于A，因此我们可以复用A的内存空间。所以这样一个enum至少需要104个bit。但是由于内存对齐的原因，第一个i8要和后面的i64对齐，所以要补上7个i8，因为7&lt;/em>8+8=64嘛。
补完之后我们发现，那个i32也可以被用来补完的7个i8来表示了（4个i8凑一凑就一个i32了嘛）。于是这个enum就是8个i8+1个i64组成了。&lt;/p>
&lt;p>现在来看看当它们分别是A，B，C时的情况。
当enum是A的时候，它的结构会转换成{i8, i32,
i64}.第一个用于标号，是0.第二个是A的第一个域，i32，i64是第二个域。用于内存对齐的i8被llvm自动藏起来了。完整的表示是{i8,
[3 x i8], i32, i64}，中间3个i8会隐藏掉。
当enum是B的时候，结构就变成了{i8,i8}后面的一大堆东西统统不要。所以如果一个enum要是被这样构造了，每一个B都会浪费大量的空间（空间使用率16/128=12.5%）。对于单片机编程来说要尽量避免这种情况。
当enum是C的时候，结构是{i8,float},[3xi8]同A，会隐藏起来。后面浪费了一个i64.利用率50%，也挺低。&lt;/p>
&lt;ul>
&lt;li>1和2混搭&lt;/li>
&lt;/ul>
&lt;p>如下enum：&lt;/p>
&lt;pre>&lt;code class="language-rust">enum simple {
A(i32,i64),
B(u8),
C(f32),
D,
E
}
&lt;/code>&lt;/pre>
&lt;p>具体情况和union enum差不多。后面两个D和E变成{i8}罢了。&lt;/p>
&lt;ul>
&lt;li>泛型enum&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-rust"> enum simple&amp;lt;T&amp;gt; {
Data(T),
Nil
}
let a = simple::Data::&amp;lt;int&amp;gt;(1);
let b = simple::Nil::&amp;lt;uint&amp;gt;;
&lt;/code>&lt;/pre>
&lt;p>泛型其实只是生成了两份代码，一个叫&lt;code>%&amp;quot;enum.main::simple&amp;lt;[int]&amp;gt;&amp;quot; = type { i8, [7 x i8], [1 x i64] }&lt;/code>，
另一个叫&lt;code>%&amp;quot;enum.main::simple&amp;lt;[uint]&amp;gt;&amp;quot; = type { i8, [7 x i8], [1 x i64] }&lt;/code>，其它无任何差别。&lt;/p>
&lt;ul>
&lt;li>struct variant&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-rust">enum simple {
duck {a: int, b: int},
Nil
}
let a = simple::duck{a:4,b:3};
&lt;/code>&lt;/pre>
&lt;p>和普通的enum一样，只是给duck里面的两个i64起个名字罢了。在ir层面没有任何区别。&lt;/p>
&lt;ul>
&lt;li>#[repr(C)]&lt;/li>
&lt;/ul>
&lt;p>rust还支持把enum的内存表示变为C风格的。&lt;/p>
&lt;pre>&lt;code class="language-rust">#[repr(C)]
enum simple {
a(int),
b,c
}
&lt;/code>&lt;/pre>
&lt;p>这儿的区别在于，头部的标号和内存对齐，全部从i8变成了i32，即C的int。&lt;code>{i32, [1 x i32], i64}&lt;/code>&lt;/p></description></item><item><title>Rust Object</title><link>http://wooya.me/post/rust-object/</link><pubDate>Wed, 04 Nov 2015 11:49:25 +0800</pubDate><guid>http://wooya.me/post/rust-object/</guid><description>&lt;p>rust有非常强大的类型系统。今天我们来说说rust的泛型。&lt;/p>
&lt;p>rust有两种泛型：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>基于&lt;code>static dispatch&lt;/code>的泛型，类似于C++的模板。在编译期进行代码特化（monomorphization），为每一种类型生成一份代码。好处是执行效率高，但是会带来额外的冗余代码，使二进制文件变大（bloat）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>基于&lt;code>dynamic dispatch&lt;/code>的泛型，类似于java和go的&lt;code>interface&lt;/code>。在运行期查找虚表（vtable）来选择执行的方法。好处是使用灵活，但是性能肯定比static dispatch来的差。本篇着重介绍这一种泛型。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr/>
&lt;ul>
&lt;li>Trait Object&lt;/li>
&lt;/ul>
&lt;p>rust的&lt;code>dynamic dispatch&lt;/code>实现都是基于一种叫做&lt;code>trait object&lt;/code>的类型来实现的。先看一个例子：&lt;/p>
&lt;pre>&lt;code class="language-rust"> trait Object {
fn dood(&amp;amp;self) -&amp;gt; int {
1i
}
}
impl Object for int {}
impl Object for uint {}
fn main() {
fn gimme_an_object(i: &amp;amp;Object) {
println!(&amp;quot;{}&amp;quot;, i.dood());
}
gimme_an_object(&amp;amp;2i); // OUTPUT: 1
gimme_an_object(&amp;amp;3u); // OUTPUT: 1
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>gimme_an_object&lt;/code>函数这里发生了什么？
可以看到，&lt;code>gimme_an_object&lt;/code>需要传入一个&amp;amp;Object类型的参数。就是说，&lt;code>gimme_an_object&lt;/code>函数的参数i是一个实现了Object这个trait的引用类型。所以我们无论喂给它了一个&amp;amp;int或一个&amp;amp;uint，它都能完成调用。因为之前的两个&lt;code>impl&lt;/code>已经为&lt;code>uint&lt;/code>类型和&lt;code>int&lt;/code>类型实现了&lt;code>Object&lt;/code>这个&lt;code>trait&lt;/code>。
在这一点上，rust的trait和go的interface很相似。我们只需要传入一个接口，函数就能完成工作，为不用管传入的参数到底是什么类型。
但是这里有一个细节需要注意：为什么要写&lt;code>&amp;amp;Object&lt;/code>，写成&lt;code>fn gimme_an_object(i: Object)&lt;/code>不行吗？
答案是不行。有人可能很奇怪，为什么我在go里面直接写interface就没问起，rust里面却必须要加个引用呢？
原因有两个：&lt;/p>
&lt;ol>
&lt;li>&lt;/li>
&lt;/ol>
&lt;p>因为按照rust的设计用途，它可以做底层开发，也可以做上层开发。因此内存布局要尽可能的”raw“。所有的数据都是赤裸裸的躺在堆上或栈上。因此一个Object的大小是不确定的。比如你可以为一个i8实现Object，再为一个u64实现Object。它们都能被当错参数传进&lt;code>gimme_an_object&lt;/code>，但是显然他们的大小是不一样的（不考虑内存对齐）。对于动态长度的类型，显然没法在栈上分配空间，因为他们是编译时位置长度的。所以要用一个指针指向某个实现了trait的对象。因为指针是编译时大小已知的。
同理，像go、java也不可能绕过这个限制，毕竟他们不是黑魔法。之所以他们能直接写&lt;code>func(i interface{})&lt;/code>的原因，是因为它们的interface自己就是一个指针。他们没有写嵌入式的负担，又有GC的照顾，自然可以肆无忌惮的用指针来指向一个类型并且把一切都隐藏起来就好像interface里的数据真真切切就在那儿一样。其实只是个indirection而已。
2. rust有三种原生指针，&amp;amp;、Box和*。无论哪一种都可以作为trait
object的indirection，因此要是用interface一统江湖，不再写&amp;amp;，必然导致灵活性下降。无论用哪一种作为trait&lt;br>
object的默认指针都有失偏颇。&lt;/p>
&lt;ul>
&lt;li>trait object的编译器魔法。&lt;/li>
&lt;/ul>
&lt;p>在rust里，所有的指针都是一个字长。比如64位机器上，&amp;amp;1i的大小就是64个bit。
但是在trait object中，rust编译器会隐式的把指针转换为一个胖指针。&lt;/p>
&lt;pre>&lt;code class="language-rust"> // in core::raw::TraitObject
struct TraitObject {
data: *mut (),
vtable: *mut (),
}
&lt;/code>&lt;/pre>
&lt;p>也就是说，所有的TraitObject大小其实都是两个字长。第一个指向数据，第二个指向虚函数表。这点和go的interface其实是一模一样的。&lt;/p>
&lt;ul>
&lt;li>trait safety&lt;/li>
&lt;/ul>
&lt;p>对于trait object，rust还有一个限制：只有safe的trait才能被用作trait object。
什么叫safe的trait呢？
因为有些trait会返回一个self类型，比如：&lt;/p>
&lt;pre>&lt;code class="language-rust"> trait RetSelf {
fn ret_self(&amp;amp;self) -&amp;gt; Self;
}
&lt;/code>&lt;/pre>
&lt;p>如果impl给了int，那么ret_self方法的返回值就是一个int，要是impl给了f64，那么返回值就是一个f64.这就意味着代码诸如：&lt;/p>
&lt;pre>&lt;code class="language-rust"> fn unsafe_object(i: &amp;amp;RetSelf) {
let c = i.ret_self();
}
&lt;/code>&lt;/pre>
&lt;p>是无法编译的，因为无从知道c的大小。因此在rust里面，只有不带有fn() -&amp;gt;
Self类型的方法的trait才叫safe的trait，只有safe的trait才能被用作trait object。这也是为什么rust有很多trait xxxx，
trait XXXXEXT。因为XXXX是safe的object，而trait
XXXXEXT里面包含了带有返回Self的方法。如果把两者合并为同一个trait，意味着trait XXXX将不能再用于trait
object。因此必须用两个trait来吧unsafe的方法隔离开。比如常用的Iterator
trait就是如此。它从以前的一个trait变成了如今的interator和iteratorExt.&lt;/p></description></item><item><title>Talk About Phantom Type</title><link>http://wooya.me/post/rust-phantom-type/</link><pubDate>Mon, 02 Nov 2015 10:36:23 +0800</pubDate><guid>http://wooya.me/post/rust-phantom-type/</guid><description>&lt;p>在具有高级类型系统的语言里面，有一种类型标记的用法叫phantom type,
比如
&lt;a href="http://www.haskell.org/haskellwiki/Phantom_type" target="_blank" rel="noopener">Haskell语言&lt;/a>
。这种用法有个很有意思用途：用来做编译时的类型检查，并且对于编译后的代码来说，完全没有任何的副作用。&lt;/p>
&lt;p>举个例子，在做几何运算的时候，我们会碰到运算时变量单位的问题。&lt;/p>
&lt;pre>&lt;code class="language-rust">#[deriving(Show)]
struct Length&amp;lt;Num&amp;gt;(Num);
type Meter = f64;
type Inch = f64;
let a: Length&amp;lt;Meter&amp;gt; = Length(5.0 as Meter);
let b: Length&amp;lt;Inch&amp;gt; = Length(7.0 as Inch);
impl&amp;lt;Num&amp;gt; Add&amp;lt;Length&amp;lt;Num&amp;gt;,Length&amp;lt;Num&amp;gt;&amp;gt; for Length&amp;lt;Num&amp;gt; where Num: Add&amp;lt;Num,Num&amp;gt; {
fn add(self, rhs: Length&amp;lt;Num&amp;gt;) -&amp;gt; Length&amp;lt;Num&amp;gt; {
Length(self.0 + rhs.0)
}
}
println!(&amp;quot;{}&amp;quot;, a + b);
&lt;/code>&lt;/pre>
&lt;p>在上面的代码中，我们有一个很明显的bug,单位为米的a竟然和单位为英寸的b进行了相加。要是在业务逻辑中出现这么一茬，肯定很难debug，因为从语法上来讲，完全没有问题啊！&lt;/p>
&lt;p>现在我们来引入一种类型系统的trick，叫做phantom type。&lt;/p>
&lt;pre>&lt;code class="language-rust">mod unit {
#[deriving(Show)]
enum Meter {}
#[deriving(Show)]
enum Inch {}
}
#[deriving(Show)]
struct Length&amp;lt;Unit,Num&amp;gt;(Num);
let a: Length&amp;lt;unit::Meter,f64&amp;gt; = Length(5.0);
let b: Length&amp;lt;unit::Inch,f64&amp;gt; = Length(7.0);
impl&amp;lt;Unit,Num&amp;gt; Add&amp;lt;Length&amp;lt;Unit,Num&amp;gt;,Length&amp;lt;Unit,Num&amp;gt;&amp;gt; for Length&amp;lt;Unit,Num&amp;gt; where Num: Add&amp;lt;Num,Num&amp;gt; {
fn add(self, rhs: Length&amp;lt;Unit,Num&amp;gt;) -&amp;gt; Length&amp;lt;Unit,Num&amp;gt; {
Length(self.0 + rhs.0)
}
}
println!(&amp;quot;{}&amp;quot;, a + b);
&lt;/code>&lt;/pre>
&lt;p>为了打印方便，加了一些&lt;code>#[deriving(Show)]&lt;/code>。 我们给Length类型加上了一个&lt;code>Unit &lt;/code>的类型标记。但是，Unit却没有出现在任何有值的地方，它仅仅是作为了一个类型标记存在着。所以，我想这也是为什么它叫&lt;code>phantom type&lt;/code>的原因吧。&lt;/p>
&lt;p>编译上面那段的代码，编译器会给你报错：&lt;/p>
&lt;pre>&lt;code class="language-rust">error: mismatched types: expected `main::Length&amp;lt;main::unit::Meter, f64&amp;gt;`, found `main::Length&amp;lt;main::unit::Inch,
f64&amp;gt;` (expected enum main::unit::Meter,found enum main::unit::Inch)
&lt;/code>&lt;/pre>
&lt;p>编译器说： a是&lt;code>Length&amp;lt;Meter,f64&amp;gt;&lt;/code>, b是&lt;code>&amp;lt;Inch，f64&amp;gt;&lt;/code>,它们类型不相容。&lt;/p>
&lt;p>仅仅通过增加一个额外的类型标记，我们就实现了让编译器自动给我们检查单位的方法，而且这种&lt;code>phantom type&lt;/code>的小trick，不会带来任何的运行时负担。在编译完毕后，它们就被一并的擦除了。&lt;/p>
&lt;p>其实这是一种对现实中单位制的模拟。平时我们写的时候一般写
1m，2mm之类。其实当我们写下了1m这个数字的时候，其实着我们写下了两个东西，作为数字的1和作为单位的m。单独拿出来，对于数字1来讲，他没有任何的意义。可以随便对他加上其它的数字；对于m来说，它仅仅是个单位，同样也没有意义。但是1m结合起来，m就为1赋予了class信息，改变了它的运算规则。&lt;code>phantom type&lt;/code>在此，就起到了这个量纲作用。&lt;/p>
&lt;p>除了用来作为数字的单位以外，还有一个比较好用的地方是作为用户输入安全性的标记（这和rust着重安全是遥相呼应啊）。
众所周知，web安全有很大一部分问题，是因为没有对用户输入做检查。一个安全的系统应该对于所有的用户输入采取不信任的态度，应该由代码对其进行检查。
但是在开发的时候，可能由于程序员水平问题，或者一时疏忽等原因，往往会忘记检查。这就为系统埋下了很大的隐患。
利用&lt;code>phantom type&lt;/code>我们可以为所有的string打上tag，让编译器来替我们进行检查。&lt;/p>
&lt;pre>&lt;code class="language-rust">enum Trusted {}
enum UnTrusted {}
struct UserInput&amp;lt;T&amp;gt;(String);
let a: UserInput&amp;lt;Trusted&amp;gt;(&amp;quot;safe&amp;quot;.to_string());
let b: UserInput&amp;lt;UnTrusted&amp;gt;(&amp;quot;SQL Injectiong is here!!!&amp;quot;.to_string());
insert_into_database(a);
insert_into_database(b); // 编译通不过
&lt;/code>&lt;/pre>
&lt;p>假定我们的&lt;code>insert_into_database&lt;/code>接受一个&lt;code>UserInput&amp;lt;Trusted&amp;gt;&lt;/code>作为输入。那么那个b，我们是无论如何也无法存入数据库的，必须要我们进行显式的检查，将其转换为UserInput&lt;Trusted>,否则编译必定报错。这样系统的安全性就大大的加强了。&lt;/p></description></item></channel></rss>