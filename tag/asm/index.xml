<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>asm | Ya!</title><link>https://wooya.me/tag/asm/</link><atom:link href="https://wooya.me/tag/asm/index.xml" rel="self" type="application/rss+xml"/><description>asm</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>© 2022 Weiyuan</copyright><lastBuildDate>Wed, 04 Nov 2015 11:53:30 +0800</lastBuildDate><image><url>https://wooya.me/media/icon_hu54ee143ef1e070b207dc27cd44346347_16508_512x512_fill_lanczos_center_3.png</url><title>asm</title><link>https://wooya.me/tag/asm/</link></image><item><title>Rust Inline ASM</title><link>https://wooya.me/post/rust-inline-asm/</link><pubDate>Wed, 04 Nov 2015 11:53:30 +0800</pubDate><guid>https://wooya.me/post/rust-inline-asm/</guid><description>&lt;p>rust和c/c++一样,可以内联汇编.语法和c/c++的内联汇编大致一样.只有几个细节稍有不同.&lt;/p>
&lt;p>首先,需要开启一个特性 &lt;code>#![feature(asm)]&lt;/code>&lt;/p>
&lt;p>然后在&lt;code>asm!&lt;/code>宏里面写汇编即可.&lt;/p>
&lt;p>格式是:&lt;/p>
&lt;pre>&lt;code>asm!(assembly template
: output operands
: input operands
: clobbers
: options
);
&lt;/code>&lt;/pre>
&lt;p>大致和c/c++相同.其中有几个不同点:&lt;/p>
&lt;p>在最后一段用来声明已经使用过的寄存器的那一段(clobbers)下面还可以跟一段option段.备选项有:&amp;ldquo;intel&amp;quot;表示采用intel汇编而不像c那样用AT&amp;amp;T汇编.&amp;ldquo;volatile&amp;rdquo;,和c里面的&lt;code>__asm__volatile__&lt;/code>一样.&amp;ldquo;alignstack&amp;rdquo;,让编译器自动插入对齐栈的代码(因为有些指令集需要对齐栈,比如SSE指令集).
在填充模版的时候,变量用$0,$1来表示,而不是c的%1,%2来表示.
立即数用&lt;code>$$&lt;/code>表示,&lt;code>$$1&lt;/code>就是1.
寄存器直接用%来表示,%eax表示eax寄存器
模版里面多条指令用分号(;)来分割,而不是c的&amp;rdquo;\r\n&amp;quot;
声明clobber的时候直接写&lt;code>eax&lt;/code>,不用像C那样写&lt;code>%eax&lt;/code>
记得&lt;code>asm!&lt;/code>的时候要外面套&lt;code>unsafe&lt;/code>块
intel语法我没有试过.所以无从比较语法区别:(&lt;/p>
&lt;p>下面附上我的一个小例子,用汇编+偏移量来访问数组.&lt;/p>
&lt;pre>&lt;code class="language-rust">#![feature(asm)]
fn main() {asm();}
#[cfg(target_arch = &amp;quot;x86_64&amp;quot;)]
fn asm() {
use std::mem::transmute;
use std::rand::random;
let array: &amp;amp;[u64] = &amp;amp;[random(),random(),random(),random()];
let address = unsafe { transmute::&amp;lt;_, (i64, i64)&amp;gt;(array).0 };
for offset in 0u64..4 {
let ret: u64;
unsafe {
asm!(
r&amp;quot;
mov ($1, $2, 8), %rax;
mov %rax, $0;
&amp;quot;
: &amp;quot;=r&amp;quot;(ret)
: &amp;quot;r&amp;quot;(address), &amp;quot;r&amp;quot;(offset)
: &amp;quot;rax&amp;quot;
:
);
}
println!(&amp;quot;在第{}号位上的元素是{}&amp;quot;, offset, ret);
}
}
&lt;/code>&lt;/pre></description></item></channel></rss>