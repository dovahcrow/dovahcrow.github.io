<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>linearization | Ya!</title><link>https://wooya.me/tag/linearization/</link><atom:link href="https://wooya.me/tag/linearization/index.xml" rel="self" type="application/rss+xml"/><description>linearization</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>© 2022 Weiyuan</copyright><lastBuildDate>Sat, 09 Apr 2016 17:35:01 +0800</lastBuildDate><image><url>https://wooya.me/media/icon_hu54ee143ef1e070b207dc27cd44346347_16508_512x512_fill_lanczos_center_3.png</url><title>linearization</title><link>https://wooya.me/tag/linearization/</link></image><item><title>Python C3 Linearization</title><link>https://wooya.me/post/python-c3-linearization/</link><pubDate>Sat, 09 Apr 2016 17:35:01 +0800</pubDate><guid>https://wooya.me/post/python-c3-linearization/</guid><description>&lt;p>本文讲解了python的方法搜索优先级, &lt;code>super&lt;/code>函数的调用以及python的线性化算法&lt;code>C3&lt;/code>.&lt;/p>
&lt;p>昨天在搞python多继承的时候遇到一个问题抽象化如下:&lt;/p>
&lt;pre>&lt;code class="language-python">class A:
def foo(self):
print(&amp;quot;A&amp;quot;)
class B:
def foo(self):
print(&amp;quot;B&amp;quot;)
super().foo()
class C(B,A):
def foo(self):
print(&amp;quot;C&amp;quot;)
super().foo()
&lt;/code>&lt;/pre>
&lt;p>调用&lt;code>C().foo()&lt;/code>会输出:&lt;/p>
&lt;pre>&lt;code class="language-python">C
B
A
&lt;/code>&lt;/pre>
&lt;p>其中第一行输出&lt;code>C&lt;/code>很好理解, 第二行&lt;code>类B的foo&lt;/code>输出&lt;code>B&lt;/code>以后调用了&lt;code>super&lt;/code>的&lt;code>foo方法&lt;/code>。但是如果&lt;code>B的foo&lt;/code>:&lt;/p>
&lt;ol>
&lt;li>调用了&lt;code>B&lt;/code>的&lt;code>super&lt;/code>, 则因为&lt;code>B&lt;/code>并没有父类, 所以&lt;code>super().foo()&lt;/code>的调用应该会失败，抛出&lt;code>AttributeError&lt;/code>错误。&lt;/li>
&lt;li>调用了&lt;code>self&lt;/code>的&lt;code>super&lt;/code>, 由于此时&lt;code>self&lt;/code>的类型是&lt;code>C&lt;/code>, 那么又会去调用&lt;code>B&lt;/code>的&lt;code>foo&lt;/code>形成无限递归调用.&lt;/li>
&lt;/ol>
&lt;p>然而事实上并没有发生以上两种情况。&lt;code>B&lt;/code>的&lt;code>super&lt;/code>竟然调用了&lt;code>A&lt;/code>的&lt;code>foo&lt;/code>.&lt;/p>
&lt;p>其实个人觉得这里的&lt;code>super&lt;/code>有些误导人, &lt;code>super&lt;/code>并不一定是去寻找父类, 它的意思是: 沿着方法搜索序列(&lt;code>mro&lt;/code>)往上搜索一格。
要理解&lt;code>mro&lt;/code>, 首先需要知道什么是&lt;code>linearization&lt;/code>.&lt;/p>
&lt;p>&lt;code>linearization&lt;/code>一般出现在具有多继承的语言中, 比如scala, python等.
因为多继承必然会带来方法冲突等问题从而导致方法搜索失败, 所以必须规定一个方法搜索顺序防止冲突, 线性的从最底部叶
子类开始向上搜索方法直到找到或失败. 这就要求把一棵继承树变化成一个一维的线性结构.&lt;/p>
&lt;p>在python中线性化的算法是一种叫做&lt;code>C3&lt;/code>的算法. 来自论文&lt;a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.3910" target="_blank" rel="noopener">A Monotonic Superclass Linearization for Dylan&lt;/a>.&lt;/p>
&lt;p>它的描述如下(来自wikipedia):&lt;/p>
&lt;blockquote>
&lt;p>对于以下的类型:&lt;/p>
&lt;pre>&lt;code>&lt;/code>&lt;/pre>
&lt;/blockquote>
&lt;p>class O
class A extends O
class B extends O
class C extends O
class D extends O
class E extends O
class K1 extends A, B, C
class K2 extends D, B, E
class K3 extends D, A
class Z extends K1, K2, K3&lt;/p>
&lt;pre>&lt;code>&amp;gt; 他们的线性化(即方法搜索顺序)是:
&amp;gt; ```
L(O) := [O] // the linearization of O is trivially the singleton list [O], because O has no parents
L(A) := [A] + merge(L(O), [O]) // the linearization of A is A plus the merge of its parents' linearizations with the list of parents...
= [A] + merge([O], [O])
= [A, O] // ...which simply prepends A to its single parent's linearization
L(B) := [B, O] // linearizations of B, C, D and E are computed similar to that of A
L(C) := [C, O]
L(D) := [D, O]
L(E) := [E, O]
L(K1) := [K1] + merge(L(A), L(B), L(C), [A, B, C]) // first, find the linearizations of K1's parents, L(A), L(B), and L(C), and merge them with the parent list [A, B, C]
= [K1] + merge([A, O], [B, O], [C, O], [A, B, C]) // class A is a good candidate for the first merge step, because it only appears as the head of the first and last lists
= [K1, A] + merge([O], [B, O], [C, O], [B, C]) // class O is not a good candidate for the next merge step, because it also appears in the tails of list 2 and 3, but...
= [K1, A, B] + merge([O], [O], [C, O], [C]) // ...class B qualified, and so does class C; class O still appears in the tail of list 3
= [K1, A, B, C] + merge([O], [O], [O]) // finally, class O is a valid candidate, which also exhausts all remaining lists
= [K1, A, B, C, O]
L(K2) := [K2] + merge(L(D), L(B), L(E), [D, B, E])
= [K2] + merge([D, O], [B, O], [E, O], [D, B, E]) // select D
= [K2, D] + merge([O], [B, O], [E, O], [B, E]) // fail O, select B
= [K2, D, B] + merge([O], [O], [E, O], [E]) // fail O, select E
= [K2, D, B, E] + merge([O], [O], [O]) // select O
= [K2, D, B, E, O]
L(K3) := [K3] + merge(L(D), L(A), [D, A])
= [K3] + merge([D, O], [A, O], [D, A]) // select D
= [K3, D] + merge([O], [A, O], [A]) // fail O, select A
= [K3, D, A] + merge([O], [O]) // select O
= [K3, D, A, O]
L(Z) := [Z] + merge(L(K1), L(K2), L(K3), [K1, K2, K3])
= [Z] + merge([K1, A, B, C, O], [K2, D, B, E, O], [K3, D, A, O], [K1, K2, K3]) // select K1
= [Z, K1] + merge([A, B, C, O], [K2, D, B, E, O], [K3, D, A, O], [K2, K3]) // fail A, select K2
= [Z, K1, K2] + merge([A, B, C, O], [D, B, E, O], [K3, D, A, O], [K3]) // fail A, fail D, select K3
= [Z, K1, K2, K3] + merge([A, B, C, O], [D, B, E, O], [D, A, O]) // fail A, select D
= [Z, K1, K2, K3, D] + merge([A, B, C, O], [B, E, O], [A, O]) // select A
= [Z, K1, K2, K3, D, A] + merge([B, C, O], [B, E, O], [O]) // select B
= [Z, K1, K2, K3, D, A, B] + merge([C, O], [E, O], [O]) // select C
= [Z, K1, K2, K3, D, A, B, C] + merge([O], [E, O], [O]) // fail O, select E
= [Z, K1, K2, K3, D, A, B, C, E] + merge([O], [O], [O]) // select O
= [Z, K1, K2, K3, D, A, B, C, E, O] // done
&lt;/code>&lt;/pre>
&lt;p>比如要调用&lt;code>Z().foo()&lt;/code>, 然而&lt;code>D&lt;/code>和&lt;code>A&lt;/code>都定义了&lt;code>foo&lt;/code>这个方法, 则根据&lt;code>Z&lt;/code>的线性化&lt;code>L(Z) := [Z, K1, K2, K3, D, A, B, C, E, O]&lt;/code>, 第一个搜索到的&lt;code>foo&lt;/code>应该来自&lt;code>D&lt;/code>。&lt;/p>
&lt;p>这样的话就完美解释了上文第一个例子中为什么&lt;code>B&lt;/code>的&lt;code>super().foo()&lt;/code>调用了&lt;code>A&lt;/code>的&lt;code>foo&lt;/code>:&lt;/p>
&lt;p>&lt;code>super()&lt;/code>其实是&lt;code>super(__class__, self)&lt;/code>的简写, 它的作用是在&lt;code>self&lt;/code>的线性化上排除掉自己以及自己之前的类型.&lt;/p>
&lt;p>比如&lt;code>B&lt;/code>中的&lt;code>super()&lt;/code>其实是&lt;code>super(__class__, self)&lt;/code>就是&lt;code>super(B, self)&lt;/code>. 其中&lt;code>self&lt;/code>为&lt;code>C&lt;/code>.&lt;/p>
&lt;p>比如因为&lt;code>C&lt;/code>线性化为&lt;code>L(C) := [C, B, A]&lt;/code>, &lt;code>C&lt;/code>中调用&lt;code>super&lt;/code>, 在线性化结果上排除自己以及之前的类型，则产生搜索顺序&lt;code>[B, A]&lt;/code>, 所以&lt;code>C&lt;/code>中&lt;code>super().foo()&lt;/code>调用的结果是调用了&lt;code>B&lt;/code>的&lt;code>foo&lt;/code>.&lt;/p>
&lt;p>而在&lt;code>B&lt;/code>中调用&lt;code>super()&lt;/code>排除自己&lt;code>B&lt;/code>以及之前的类型&lt;code>C&lt;/code>, 产生搜索顺序&lt;code>[A]&lt;/code>, 所以&lt;code>B&lt;/code>中&lt;code>super().foo()&lt;/code>调用的结果是调用了&lt;code>A&lt;/code>的&lt;code>foo&lt;/code>.&lt;/p>
&lt;p>这个线性化结果可以通过python的类的&lt;code>mro&lt;/code>方法进行查看。&lt;/p>
&lt;pre>&lt;code class="language-python">C.mro() == [C, B, A]
&lt;/code>&lt;/pre></description></item></channel></rss>