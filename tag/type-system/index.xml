<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>type system | Ya!</title><link>https://wooya.me/tag/type-system/</link><atom:link href="https://wooya.me/tag/type-system/index.xml" rel="self" type="application/rss+xml"/><description>type system</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>© 2022 Weiyuan</copyright><lastBuildDate>Fri, 13 May 2016 18:41:28 +0800</lastBuildDate><image><url>https://wooya.me/media/icon_hu54ee143ef1e070b207dc27cd44346347_16508_512x512_fill_lanczos_center_3.png</url><title>type system</title><link>https://wooya.me/tag/type-system/</link></image><item><title>Multipledispatch2</title><link>https://wooya.me/post/multipledispatch2/</link><pubDate>Fri, 13 May 2016 18:41:28 +0800</pubDate><guid>https://wooya.me/post/multipledispatch2/</guid><description>&lt;p>本文讲述了笔者的multipledispatch2库的一些技术细节.&lt;/p>
&lt;p>由于是从静态语言切换成的python使用者, 笔者对python的动态类型非常不适应. 因此几乎每个地方都会使用multipledispatch给保护一下.&lt;/p>
&lt;p>然后用久了感觉有几个不方便:&lt;/p>
&lt;ol>
&lt;li>&lt;code>multipledispatch&lt;/code>不支持函数参数的类型签名. &lt;code>python 3.5&lt;/code>加入了&lt;code>typing&lt;/code>库, 表示&lt;code>def foo(bar: int, baz: str) -&amp;gt; list&lt;/code>这种写法是官方提倡的, 然而multipledispatch却不支持这种写法.&lt;/li>
&lt;li>&lt;code>multipledispatch&lt;/code>不支持一个类型是多个类型的子类型的写法, 比如我想表达&lt;code>A &amp;lt;: B &amp;amp;&amp;amp; A &amp;lt;: C&lt;/code>时就无能为力了.&lt;/li>
&lt;/ol>
&lt;p>由于给作者提issue以后作者几个月没动静, 因此在&lt;code>multipledispatch&lt;/code>的基础上, 笔者修改了一些代码, 发布了multipledispatch2.&lt;/p>
&lt;p>主要改动是:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>增加了对&lt;code>type annotation&lt;/code>的支持, 即:
对于原来的&lt;/p>
&lt;pre>&lt;code class="language-python">@dispatch(int, str)
def foo(a, b):
pass
&lt;/code>&lt;/pre>
&lt;p>现在可以写作:&lt;/p>
&lt;pre>&lt;code class="language-python">@dispatch
def foo(a: int, b: str):
pass
&lt;/code>&lt;/pre>
&lt;p>相对更自然了一点.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>增加了对&lt;code>subtype of multiple types&lt;/code>的支持:&lt;/p>
&lt;pre>&lt;code class="language-python">class A: pass
class B: pass
class C(A, B): pass
@dispatch
def foo(a: [A, B]):
pass
&lt;/code>&lt;/pre>
&lt;p>对于调用&lt;code>foo(x)&lt;/code>, 当且仅当入参&lt;code>x&lt;/code>同时是&lt;code>A&lt;/code>和&lt;code>B&lt;/code>的子类时, 对foo的调用才会成立. 在上例中只有&lt;code>foo(C())&lt;/code>是成立的.&lt;/p>
&lt;p>这个新特性对于写库的人来说十分方便, 比如当你想要使用&lt;code>trait&lt;/code>来做&lt;code>mixin&lt;/code>的时候, users可能会拿你的&lt;code>trait&lt;/code>混合出很多&lt;code>subtypes&lt;/code>. 如果你想要提供一些函数来操作这些&lt;code>subtypes&lt;/code>, 比如有一个函数当参数&lt;code>mixin&lt;/code>了&lt;code>class A&lt;/code>时产生behavior1, &lt;code>mixin&lt;/code>了&lt;code>class B&lt;/code>时产生behavior2, 同时&lt;code>mixin&lt;/code>了&lt;code>class A&lt;/code>和&lt;code>class B&lt;/code>时, 产生behavior3. 在这种情况下, 使用原有的&lt;code>multipledispatch&lt;/code>是不可能的.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="技术细节">技术细节:&lt;/h2>
&lt;p>主要问题在于&lt;code>dispatch order&lt;/code>上. 比如: 对于同一个函数名foo, 它有两种类型:&lt;/p>
&lt;ol>
&lt;li>&lt;code>foo(a: A, b: B): pass&lt;/code>&lt;/li>
&lt;li>&lt;code>foo(a: C, b: B): pass&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>其中:&lt;/p>
&lt;pre>&lt;code class="language-python">class A: pass
class B: pass
class C(A): pass
class D(C): pass
&lt;/code>&lt;/pre>
&lt;p>当你传入参数&lt;code>(C, B)&lt;/code>的时候, 显然希望调用的是2而不是1, 当传入&lt;code>(D, B)&lt;/code>的时候, 显然也希望调用2而不是1.只有当传入&lt;code>(A, B)&lt;/code>时, 才希望调用的是1.&lt;/p>
&lt;p>用形象的话来说: 对于入参&lt;code>X&lt;/code>, 希望被调用的函数是拥有&lt;code>最具体&lt;/code>的签名的那个函数.&lt;/p>
&lt;p>于是这就要求我们有一个排序方法将&lt;code>foo&lt;/code>的所有签名进行排序, 越具体的签名尽可能在前面. 进行签名搜索时, 应该从头开始搜, 并采纳第一个适合的签名.&lt;/p>
&lt;p>还是上面那个例子, 如果我们能够产生一个搜索顺序: &lt;code>[(C, B), (A, B)]&lt;/code>, 那不就符合要求了?&lt;/p>
&lt;p>对于排序, 显然需要一个操作符&lt;code>compare&lt;/code>进行比较. 那么对于签名的&lt;code>compare&lt;/code>该如何定义呢? 即如何确定签名与签名之间谁大谁小.&lt;/p>
&lt;p>在这里我们定义&lt;code>compare&lt;/code>如下:&lt;/p>
&lt;pre>&lt;code>令 A, B 为 tuple of types
if A.length == b.length then
A compare B := A &amp;lt;: B (即A是B的子类型)
else
return not comparable
&lt;/code>&lt;/pre>
&lt;p>而对于&lt;code>tuple of types&lt;/code>的&lt;code>&amp;lt;:&lt;/code>定义如下:&lt;/p>
&lt;pre>&lt;code>for zip(all a in A, all b in B):
a &amp;lt;: b
&lt;/code>&lt;/pre>
&lt;p>即A中每一个类型都是对应位置上B的子类型时, &lt;code>A &amp;lt;: B&lt;/code>&lt;/p>
&lt;p>这样我们定义了类型签名之间的&lt;code>subtyping&lt;/code>关系. 于是我们使用这个&lt;code>compare&lt;/code>关系对一个函数的所有签名进行拓扑排序, 结果将得到一个序列.&lt;/p>
&lt;p>注意这里使用拓扑排序而不是别的排序方法, 是因为签名之间并不是良序关系. 两个签名之间可能其实是没有任何大小关系的(上面的&lt;code>return not comparable&lt;/code>分支). 因此一个函数的所有签名其实构成了多个&lt;code>DAG&lt;/code>(有向无环图).&lt;/p>
&lt;p>按照拓扑排序得到的序列搜索, 一定能够得到&lt;code>最具体&lt;/code>的那个签名.&lt;/p>
&lt;h3 id="加入multiple-subtypes后的变化">加入&lt;code>multiple subtypes&lt;/code>后的变化:&lt;/h3>
&lt;p>上面的定义很不错, 但是没有考虑一种情况: 在&lt;code>tuple of types&lt;/code>的&lt;code>&amp;lt;:&lt;/code>定义中, 我们使用了&lt;code>a &amp;lt;: b&lt;/code>这个比较. 然而当&lt;code>multiple subtypes&lt;/code>存在的时候, &lt;code>a&lt;/code>和&lt;code>b&lt;/code>可能是一个类型, 也可能是一个联合类型&lt;code>[type, type ...]&lt;/code>. 那么如何求&lt;code>a &amp;lt;: b&lt;/code>呢?&lt;/p>
&lt;p>比如, 当&lt;/p>
&lt;pre>&lt;code class="language-python">class A: pass
class B: pass
class C(A, B): pass
&lt;/code>&lt;/pre>
&lt;p>时, 如何证明&lt;code>C &amp;lt;: [A, B]&lt;/code>呢?&lt;/p>
&lt;p>甚至是当&lt;/p>
&lt;pre>&lt;code class="language-python">class A: pass
class B: pass
class C(A): pass
class D(B): pass
&lt;/code>&lt;/pre>
&lt;p>时, 如何证明&lt;code>[C, D] &amp;lt;: [A, B]&lt;/code>呢?&lt;/p>
&lt;p>我们拓展一下&lt;code>subtyping&lt;/code>关系即可:&lt;/p>
&lt;pre>&lt;code>对于types a and b
def a &amp;lt;: b as
if a and b both are type then
return a &amp;lt;: b
else if a is type and b is tuple then
return if a &amp;lt;: all types in b
else if a is tuple and b is type then
return if any types in a &amp;lt;: b
else if a and b both are tuple then
return for all types in b if any types in a &amp;lt;: types in b
&lt;/code>&lt;/pre>
&lt;p>经过这样一个补充定义以后, &lt;code>multipledispatch2&lt;/code>就完美支持&lt;code>multiple subtypes&lt;/code>啦.&lt;/p></description></item><item><title>Talk About Phantom Type</title><link>https://wooya.me/post/rust-phantom-type/</link><pubDate>Mon, 02 Nov 2015 10:36:23 +0800</pubDate><guid>https://wooya.me/post/rust-phantom-type/</guid><description>&lt;p>在具有高级类型系统的语言里面，有一种类型标记的用法叫phantom type,
比如&lt;a href="http://www.haskell.org/haskellwiki/Phantom_type" target="_blank" rel="noopener">Haskell语言&lt;/a>。这种用法有个很有意思用途：用来做编译时的类型检查，并且对于编译后的代码来说，完全没有任何的副作用。&lt;/p>
&lt;p>举个例子，在做几何运算的时候，我们会碰到运算时变量单位的问题。&lt;/p>
&lt;pre>&lt;code class="language-rust">#[deriving(Show)]
struct Length&amp;lt;Num&amp;gt;(Num);
type Meter = f64;
type Inch = f64;
let a: Length&amp;lt;Meter&amp;gt; = Length(5.0 as Meter);
let b: Length&amp;lt;Inch&amp;gt; = Length(7.0 as Inch);
impl&amp;lt;Num&amp;gt; Add&amp;lt;Length&amp;lt;Num&amp;gt;,Length&amp;lt;Num&amp;gt;&amp;gt; for Length&amp;lt;Num&amp;gt; where Num: Add&amp;lt;Num,Num&amp;gt; {
fn add(self, rhs: Length&amp;lt;Num&amp;gt;) -&amp;gt; Length&amp;lt;Num&amp;gt; {
Length(self.0 + rhs.0)
}
}
println!(&amp;quot;{}&amp;quot;, a + b);
&lt;/code>&lt;/pre>
&lt;p>在上面的代码中，我们有一个很明显的bug,单位为米的a竟然和单位为英寸的b进行了相加。要是在业务逻辑中出现这么一茬，肯定很难debug，因为从语法上来讲，完全没有问题啊！&lt;/p>
&lt;p>现在我们来引入一种类型系统的trick，叫做phantom type。&lt;/p>
&lt;pre>&lt;code class="language-rust">mod unit {
#[deriving(Show)]
enum Meter {}
#[deriving(Show)]
enum Inch {}
}
#[deriving(Show)]
struct Length&amp;lt;Unit,Num&amp;gt;(Num);
let a: Length&amp;lt;unit::Meter,f64&amp;gt; = Length(5.0);
let b: Length&amp;lt;unit::Inch,f64&amp;gt; = Length(7.0);
impl&amp;lt;Unit,Num&amp;gt; Add&amp;lt;Length&amp;lt;Unit,Num&amp;gt;,Length&amp;lt;Unit,Num&amp;gt;&amp;gt; for Length&amp;lt;Unit,Num&amp;gt; where Num: Add&amp;lt;Num,Num&amp;gt; {
fn add(self, rhs: Length&amp;lt;Unit,Num&amp;gt;) -&amp;gt; Length&amp;lt;Unit,Num&amp;gt; {
Length(self.0 + rhs.0)
}
}
println!(&amp;quot;{}&amp;quot;, a + b);
&lt;/code>&lt;/pre>
&lt;p>为了打印方便，加了一些&lt;code>#[deriving(Show)]&lt;/code>。 我们给Length类型加上了一个&lt;code>Unit &lt;/code>的类型标记。但是，Unit却没有出现在任何有值的地方，它仅仅是作为了一个类型标记存在着。所以，我想这也是为什么它叫&lt;code>phantom type&lt;/code>的原因吧。&lt;/p>
&lt;p>编译上面那段的代码，编译器会给你报错：&lt;/p>
&lt;pre>&lt;code class="language-rust">error: mismatched types: expected `main::Length&amp;lt;main::unit::Meter, f64&amp;gt;`, found `main::Length&amp;lt;main::unit::Inch,
f64&amp;gt;` (expected enum main::unit::Meter,found enum main::unit::Inch)
&lt;/code>&lt;/pre>
&lt;p>编译器说： a是&lt;code>Length&amp;lt;Meter,f64&amp;gt;&lt;/code>, b是&lt;code>&amp;lt;Inch，f64&amp;gt;&lt;/code>,它们类型不相容。&lt;/p>
&lt;p>仅仅通过增加一个额外的类型标记，我们就实现了让编译器自动给我们检查单位的方法，而且这种&lt;code>phantom type&lt;/code>的小trick，不会带来任何的运行时负担。在编译完毕后，它们就被一并的擦除了。&lt;/p>
&lt;p>其实这是一种对现实中单位制的模拟。平时我们写的时候一般写
1m，2mm之类。其实当我们写下了1m这个数字的时候，其实着我们写下了两个东西，作为数字的1和作为单位的m。单独拿出来，对于数字1来讲，他没有任何的意义。可以随便对他加上其它的数字；对于m来说，它仅仅是个单位，同样也没有意义。但是1m结合起来，m就为1赋予了class信息，改变了它的运算规则。&lt;code>phantom type&lt;/code>在此，就起到了这个量纲作用。&lt;/p>
&lt;p>除了用来作为数字的单位以外，还有一个比较好用的地方是作为用户输入安全性的标记（这和rust着重安全是遥相呼应啊）。
众所周知，web安全有很大一部分问题，是因为没有对用户输入做检查。一个安全的系统应该对于所有的用户输入采取不信任的态度，应该由代码对其进行检查。
但是在开发的时候，可能由于程序员水平问题，或者一时疏忽等原因，往往会忘记检查。这就为系统埋下了很大的隐患。
利用&lt;code>phantom type&lt;/code>我们可以为所有的string打上tag，让编译器来替我们进行检查。&lt;/p>
&lt;pre>&lt;code class="language-rust">enum Trusted {}
enum UnTrusted {}
struct UserInput&amp;lt;T&amp;gt;(String);
let a: UserInput&amp;lt;Trusted&amp;gt;(&amp;quot;safe&amp;quot;.to_string());
let b: UserInput&amp;lt;UnTrusted&amp;gt;(&amp;quot;SQL Injectiong is here!!!&amp;quot;.to_string());
insert_into_database(a);
insert_into_database(b); // 编译通不过
&lt;/code>&lt;/pre>
&lt;p>假定我们的&lt;code>insert_into_database&lt;/code>接受一个&lt;code>UserInput&amp;lt;Trusted&amp;gt;&lt;/code>作为输入。那么那个b，我们是无论如何也无法存入数据库的，必须要我们进行显式的检查，将其转换为UserInput&lt;Trusted>,否则编译必定报错。这样系统的安全性就大大的加强了。&lt;/p></description></item></channel></rss>