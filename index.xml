<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>IRIS</title><link>http://wooya.me/</link><atom:link href="http://wooya.me/index.xml" rel="self" type="application/rss+xml"/><description>IRIS</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>© 2019 Weiyüen</copyright><lastBuildDate>Mon, 27 Jan 2020 00:00:00 +0000</lastBuildDate><image><url>http://wooya.me/img/icon.png</url><title>IRIS</title><link>http://wooya.me/</link></image><item><title>Towards Complaint-driven ML Workflow Debugging</title><link>http://wooya.me/publication/mlops-2020-rain/</link><pubDate>Mon, 27 Jan 2020 00:00:00 +0000</pubDate><guid>http://wooya.me/publication/mlops-2020-rain/</guid><description>&lt;p>This is a demo paper.&lt;/p></description></item><item><title>Complaint-driven Training Data Debugging for Query 2.0</title><link>http://wooya.me/publication/sigmod-2020-rain/</link><pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate><guid>http://wooya.me/publication/sigmod-2020-rain/</guid><description/></item><item><title>Implementing Nextaction In Todoist</title><link>http://wooya.me/post/todoist-nextaction/</link><pubDate>Thu, 06 Apr 2017 17:41:28 +0800</pubDate><guid>http://wooya.me/post/todoist-nextaction/</guid><description>&lt;p>If you are a fan of MLO or Omnifocus, I bet you will really miss the nextaction feature if you migrate to Todoist. With nextaction, one can keep really focus on things he should do, which is really nice. But since Todoist hasn&amp;rsquo;t provided this feature(maybe they don&amp;rsquo;t want this forever), we need to exploit the todoist api to achieve our goal.&lt;/p>
&lt;p>Inspired by
&lt;a href="https://github.com/akramer/NextAction" target="_blank" rel="noopener">here&lt;/a>
, implementing by a polling server is a trivial but decent way. Rather than using python, I chose to write it in Rust. The rationale behind is that it should be a simple application with as less as possible dependencies, not python with lots of redundant libraries. And you can see after that the compiled docker image is only 18M which is much easier to distribute (Actually I&amp;rsquo;m considering a &amp;ldquo;nextaction as a service&amp;rdquo;, a.k.a. NaaS).&lt;/p>
&lt;h1 id="usage">Usage&lt;/h1>
&lt;h2 id="simple-run">Simple run&lt;/h2>
&lt;p>You should set environment variable &lt;code>NXTT_token&lt;/code> to your Todoist token.&lt;/p>
&lt;p>To build the application,
&lt;a href="%60https;//rustup.rs%60">rust&lt;/a>
is needed.
Run: &lt;code>git clone &amp;amp;&amp;amp; cargo run --release&lt;/code>&lt;/p>
&lt;h2 id="docker-image">Docker Image&lt;/h2>
&lt;p>A docker image is also available. Run it by &lt;code>docker run -it -e NXTT_token=&amp;lt;your Todoist token&amp;gt; wooya/nextaction&lt;/code>&lt;/p>
&lt;h1 id="introduction">Introduction&lt;/h1>
&lt;blockquote>
&lt;p>copy-pasted from the README&lt;/p>
&lt;/blockquote>
&lt;h2 id="nextaction">@nextaction&lt;/h2>
&lt;p>Nextaction will auto tag current &lt;code>nextaction&lt;/code> task with &lt;code>@nextaction&lt;/code>. It also supports parallel task (with &amp;lsquo;-&amp;rsquo; append)
and sequential task (with &amp;lsquo;:&amp;rsquo; append).&lt;/p>
&lt;p>e.g.&lt;/p>
&lt;pre>&lt;code>|-taskA:
|-taskB // This task will be tagged @nextaction
|-taskC:
|-taskD
&lt;/code>&lt;/pre>
&lt;p>after you complete taskB, it will become&lt;/p>
&lt;pre>&lt;code>|-taskA:
|-taskC:
|-taskD // This task will be tagged @nextaction
&lt;/code>&lt;/pre>
&lt;p>And for parallel tasks:&lt;/p>
&lt;pre>&lt;code>|-taskA-
|-taskB // This task will be tagged @nextaction
|-taskC // This task will also be tagged @nextaction
&lt;/code>&lt;/pre>
&lt;p>So that you can add a filter on @nextaction to make you focused.&lt;/p>
&lt;p>Parallel tasks and sequential tasks can corporate with each other seamlessly:&lt;/p>
&lt;pre>&lt;code>|-taskA-
|-taskB:
| |-taskC // This task will be tagged @nextaction
| |-taskD
|-taskE // This task will be tagged @nextaction
&lt;/code>&lt;/pre>
&lt;h2 id="someday">@someday&lt;/h2>
&lt;p>Nextaction also supports a tag called &lt;code>@someday&lt;/code>. The logic is:
when Nextaction meets a task which should be tagged &lt;code>@nextaction&lt;/code>
but currently has tag &lt;code>@someday&lt;/code>, it won&amp;rsquo;t tag &lt;code>@nextaction&lt;/code> to that task.
So that your someday tasks won&amp;rsquo;t show up on your nextaction list.&lt;/p>
&lt;p>So, don&amp;rsquo;t hesitate to deploy a nextaction server and let&amp;rsquo;s call it a day!&lt;/p></description></item><item><title>nextaction-rs</title><link>http://wooya.me/project/nextaction-rs/</link><pubDate>Thu, 06 Apr 2017 16:30:12 +0800</pubDate><guid>http://wooya.me/project/nextaction-rs/</guid><description/></item><item><title>tldextract-rs</title><link>http://wooya.me/project/tldextract-rs/</link><pubDate>Wed, 29 Mar 2017 11:17:34 +0800</pubDate><guid>http://wooya.me/project/tldextract-rs/</guid><description/></item><item><title>k2pdfopt service</title><link>http://wooya.me/project/k2pdfopt-service/</link><pubDate>Wed, 29 Mar 2017 11:13:52 +0800</pubDate><guid>http://wooya.me/project/k2pdfopt-service/</guid><description>&lt;p>It tailors pdf into kindle readable size in a foolproof way,
&lt;a href="http://wooya.me/post/kindle-pdf-optimization-service/">details&lt;/a>
.&lt;/p></description></item><item><title>sidekiq-rs</title><link>http://wooya.me/project/sidekiq-rs/</link><pubDate>Wed, 29 Mar 2017 10:47:19 +0800</pubDate><guid>http://wooya.me/project/sidekiq-rs/</guid><description>&lt;p>A sidekiq job format compatible server written in rust. So now you have a worker server running jobs 24/7 !&lt;/p></description></item><item><title>Using NIF to handle both compute-bound &amp; IO-bound tasks in elixir</title><link>http://wooya.me/talk/using-nif-to-handle-both-compute-bound-io-bound-tasks-in-elixir/</link><pubDate>Sat, 25 Mar 2017 14:00:00 +0800</pubDate><guid>http://wooya.me/talk/using-nif-to-handle-both-compute-bound-io-bound-tasks-in-elixir/</guid><description/></item><item><title>Kindle PDF Optimization Service</title><link>http://wooya.me/post/kindle-pdf-optimization-service/</link><pubDate>Thu, 22 Dec 2016 17:36:19 +0800</pubDate><guid>http://wooya.me/post/kindle-pdf-optimization-service/</guid><description>&lt;h1 id="update">Update:&lt;/h1>
&lt;p>Due to lack of funding, I decided to move it to another service provider which brings in new restrictions to this service:&lt;/p>
&lt;ul>
&lt;li>&lt;del>Total file size for a single email may not be larger than 6 MB. So if you have multiple files to convert, please send them in separate emails&lt;/del>&lt;/li>
&lt;li>Conversion of &lt;em>Each&lt;/em> file should be finished within 5 min, which means your file cannot have many pages. So if you want to convert a whole book, please cut them into small batches. In principle, this service suits most for paper reading.&lt;/li>
&lt;/ul>
&lt;p>Update, take 2: I integrated a small hack into the service as the first feature in 2018, so there&amp;rsquo;s no restriction on file size anymore.&lt;/p>
&lt;h1 id="what-it-is">What it is?&lt;/h1>
&lt;p>I&amp;rsquo;m fond of reading academic things on my Kindle, however, most academic papers are not
designed to be read on a 6-inch size screen, let alone those with two columns format.&lt;/p>
&lt;p>I took some time writing a service and now things go easy. You can just send your pdf
to &lt;code>kindle.book.converter@gmail.com&lt;/code> with your &lt;code>Send-To-Kindle&lt;/code> address
as the subject, then a cropped version of your book will be pushed to your Kindle automatically.&lt;/p>
&lt;p>Basically, this service will crop your book into a Kindle readable format
and send it pretending it is you sending the book by mocking the sender address.&lt;/p>
&lt;p>So, notice that the email used to send PDFs to &lt;code>kindle.book.converter@gmail.com&lt;/code>
should be in your
&lt;a href="https://www.amazon.com/gp/sendtokindle/email" target="_blank" rel="noopener">Approved Personal Document E-mail List&lt;/a>
.&lt;/p>
&lt;h1 id="page-selection-if-file-too-large">Page selection if file too large&lt;/h1>
&lt;p>One thing is that if the book contains too many pages, the mailer may reject sending the attachment for its huge size,
but you can enter a subset of pages (e.g. &lt;code>1-9,13,209-&lt;/code>) in the email content to shrink the result file size.
The input format is:&lt;/p>
&lt;ul>
&lt;li>Single Page - e.g. &lt;code>1&lt;/code>&lt;/li>
&lt;li>Some Pages - e.g. &lt;code>5-9&lt;/code>&lt;/li>
&lt;li>Page Since - e.g. &lt;code>10-&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>And use comma &lt;code>,&lt;/code> to combine the page selections, e.g. &lt;code>1,5-9,10-&lt;/code>, with a prepending &lt;code># &lt;/code> to indicate it&amp;rsquo;s a page selection command. There should not be any spaces inside the page selection.&lt;/p>
&lt;h1 id="additional-params">Additional params&lt;/h1>
&lt;p>Currently, this service supports params including page selection and raw k2pdfopt params by writing them in mail body. Only one
PDF file should be attached if params are used.&lt;/p>
&lt;p>Detailed grammar:&lt;/p>
&lt;ul>
&lt;li>Prepending &lt;code>#&lt;/code> with a &lt;code>space&lt;/code> to do page selection, e.g. &lt;code># 1,5-9,10-&lt;/code> (from the above example).&lt;/li>
&lt;li>Prepending &lt;code>@&lt;/code> with a &lt;code>space&lt;/code> to do pass raw params to k2pdfopt, e.g. &lt;code>@ -p 1,5-9,10-&lt;/code> is same as &lt;code># 1,5-9,10-&lt;/code> if you know the param &lt;code>-p&lt;/code> is page selection for &lt;code>k2pdfopt&lt;/code>, resulting in &lt;code>k2pdfopt -p 1,5-9,10- -o &amp;lt;filename&amp;gt;_converted.pdf &amp;lt;filename&amp;gt;&lt;/code> be called (if you know how to use &lt;code>k2pdfopt&lt;/code>, then you will definetely understand this. Otherwise, &lt;code># &lt;/code> is enough for you).&lt;/li>
&lt;/ul>
&lt;h1 id="caveat">Caveat&lt;/h1>
&lt;p>Be careful, you should not send classified documents to this address! Although I will delete them in place on the server, the document will exist in
Gmail trash for several days until Google purge the trash bin automatically. And if something goes wrong, I may replay attachments in the trash bin to debug.
So please &lt;strong>DON&amp;rsquo;T SEND CLASSIFIED&lt;/strong> or &lt;strong>PRIVATE DOCUMENTS&lt;/strong> to me in order to keep me away from legal issues.&lt;/p>
&lt;h1 id="thanks">Thanks&lt;/h1>
&lt;p>Great thanks to
&lt;a href="http://www.willus.com/" target="_blank" rel="noopener">willus&lt;/a>
who provided
&lt;a href="http://www.willus.com/k2pdfopt/" target="_blank" rel="noopener">this excellent tool&lt;/a>
to produce
the kindle readable version of pdf.&lt;/p>
&lt;center>
&lt;hr/>
&lt;p> Do you like the service? &lt;/p>
&lt;p> It costs me several bucks to maintain the server and email sending service &lt;/p>
&lt;p> I'm really &lt;strong>appreciate&lt;/strong> it if you can offer me a cup of coffee :)&lt;/p>
&lt;form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
&lt;input type="hidden" name="cmd" value="_s-xclick" />
&lt;input type="hidden" name="hosted_button_id" value="LKM2L7LDMU6ZS" />
&lt;input type="image" src="https://www.paypal.com/en_US/i/btn/btn_donate_LG.gif" border="0" name="submit" title="Offer me a coffee with Paypal :)" alt="Offer me a coffee" />
&lt;img alt="" border="0" src="https://www.paypal.com/en_US/i/scr/pixel.gif" width="1" height="1" style="margin-top: 0; margin-bottom: 0;"/>
&lt;/form>
&lt;p style="margin-top: 0; margin-bottom: 0;"> -- OR -- &lt;/p>
&lt;h3 style="margin-top: 0; margin-bottom: 0;"> Bitcoin &lt;/h3>
&lt;img ng-src="https://chart.googleapis.com/chart?chs=150x150&amp;amp;cht=qr&amp;amp;chl=1DyAXYcQy4HNWu83vRho1b8b15zqKn9qd6&amp;amp;choe=UTF-8" ng-show="showqr" src="https://chart.googleapis.com/chart?chs=150x150&amp;amp;cht=qr&amp;amp;chl=1DyAXYcQy4HNWu83vRho1b8b15zqKn9qd6&amp;amp;choe=UTF-8" style="margin-top: 0; margin-bottom: 0;">
&lt;p style="margin-top: 0; margin-bottom: 0;"> 1DyAXYcQy4HNWu83vRho1b8b15zqKn9qd6 &lt;/p>
&lt;/center></description></item><item><title>Multipledispatch2</title><link>http://wooya.me/post/multipledispatch2/</link><pubDate>Fri, 13 May 2016 18:41:28 +0800</pubDate><guid>http://wooya.me/post/multipledispatch2/</guid><description>&lt;p>本文讲述了笔者的multipledispatch2库的一些技术细节.&lt;/p>
&lt;p>由于是从静态语言切换成的python使用者, 笔者对python的动态类型非常不适应. 因此几乎每个地方都会使用multipledispatch给保护一下.&lt;/p>
&lt;p>然后用久了感觉有几个不方便:&lt;/p>
&lt;ol>
&lt;li>&lt;code>multipledispatch&lt;/code>不支持函数参数的类型签名. &lt;code>python 3.5&lt;/code>加入了&lt;code>typing&lt;/code>库, 表示&lt;code>def foo(bar: int, baz: str) -&amp;gt; list&lt;/code>这种写法是官方提倡的, 然而multipledispatch却不支持这种写法.&lt;/li>
&lt;li>&lt;code>multipledispatch&lt;/code>不支持一个类型是多个类型的子类型的写法, 比如我想表达&lt;code>A &amp;lt;: B &amp;amp;&amp;amp; A &amp;lt;: C&lt;/code>时就无能为力了.&lt;/li>
&lt;/ol>
&lt;p>由于给作者提issue以后作者几个月没动静, 因此在&lt;code>multipledispatch&lt;/code>的基础上, 笔者修改了一些代码, 发布了multipledispatch2.&lt;/p>
&lt;p>主要改动是:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>增加了对&lt;code>type annotation&lt;/code>的支持, 即:
对于原来的&lt;/p>
&lt;pre>&lt;code class="language-python">@dispatch(int, str)
def foo(a, b):
pass
&lt;/code>&lt;/pre>
&lt;p>现在可以写作:&lt;/p>
&lt;pre>&lt;code class="language-python">@dispatch
def foo(a: int, b: str):
pass
&lt;/code>&lt;/pre>
&lt;p>相对更自然了一点.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>增加了对&lt;code>subtype of multiple types&lt;/code>的支持:&lt;/p>
&lt;pre>&lt;code class="language-python">class A: pass
class B: pass
class C(A, B): pass
@dispatch
def foo(a: [A, B]):
pass
&lt;/code>&lt;/pre>
&lt;p>对于调用&lt;code>foo(x)&lt;/code>, 当且仅当入参&lt;code>x&lt;/code>同时是&lt;code>A&lt;/code>和&lt;code>B&lt;/code>的子类时, 对foo的调用才会成立. 在上例中只有&lt;code>foo(C())&lt;/code>是成立的.&lt;/p>
&lt;p>这个新特性对于写库的人来说十分方便, 比如当你想要使用&lt;code>trait&lt;/code>来做&lt;code>mixin&lt;/code>的时候, users可能会拿你的&lt;code>trait&lt;/code>混合出很多&lt;code>subtypes&lt;/code>. 如果你想要提供一些函数来操作这些&lt;code>subtypes&lt;/code>, 比如有一个函数当参数&lt;code>mixin&lt;/code>了&lt;code>class A&lt;/code>时产生behavior1, &lt;code>mixin&lt;/code>了&lt;code>class B&lt;/code>时产生behavior2, 同时&lt;code>mixin&lt;/code>了&lt;code>class A&lt;/code>和&lt;code>class B&lt;/code>时, 产生behavior3. 在这种情况下, 使用原有的&lt;code>multipledispatch&lt;/code>是不可能的.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="技术细节">技术细节:&lt;/h2>
&lt;p>主要问题在于&lt;code>dispatch order&lt;/code>上. 比如: 对于同一个函数名foo, 它有两种类型:&lt;/p>
&lt;ol>
&lt;li>&lt;code>foo(a: A, b: B): pass&lt;/code>&lt;/li>
&lt;li>&lt;code>foo(a: C, b: B): pass&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>其中:&lt;/p>
&lt;pre>&lt;code class="language-python">class A: pass
class B: pass
class C(A): pass
class D(C): pass
&lt;/code>&lt;/pre>
&lt;p>当你传入参数&lt;code>(C, B)&lt;/code>的时候, 显然希望调用的是2而不是1, 当传入&lt;code>(D, B)&lt;/code>的时候, 显然也希望调用2而不是1.只有当传入&lt;code>(A, B)&lt;/code>时, 才希望调用的是1.&lt;/p>
&lt;p>用形象的话来说: 对于入参&lt;code>X&lt;/code>, 希望被调用的函数是拥有&lt;code>最具体&lt;/code>的签名的那个函数.&lt;/p>
&lt;p>于是这就要求我们有一个排序方法将&lt;code>foo&lt;/code>的所有签名进行排序, 越具体的签名尽可能在前面. 进行签名搜索时, 应该从头开始搜, 并采纳第一个适合的签名.&lt;/p>
&lt;p>还是上面那个例子, 如果我们能够产生一个搜索顺序: &lt;code>[(C, B), (A, B)]&lt;/code>, 那不就符合要求了?&lt;/p>
&lt;p>对于排序, 显然需要一个操作符&lt;code>compare&lt;/code>进行比较. 那么对于签名的&lt;code>compare&lt;/code>该如何定义呢? 即如何确定签名与签名之间谁大谁小.&lt;/p>
&lt;p>在这里我们定义&lt;code>compare&lt;/code>如下:&lt;/p>
&lt;pre>&lt;code>令 A, B 为 tuple of types
if A.length == b.length then
A compare B := A &amp;lt;: B (即A是B的子类型)
else
return not comparable
&lt;/code>&lt;/pre>
&lt;p>而对于&lt;code>tuple of types&lt;/code>的&lt;code>&amp;lt;:&lt;/code>定义如下:&lt;/p>
&lt;pre>&lt;code>for zip(all a in A, all b in B):
a &amp;lt;: b
&lt;/code>&lt;/pre>
&lt;p>即A中每一个类型都是对应位置上B的子类型时, &lt;code>A &amp;lt;: B&lt;/code>&lt;/p>
&lt;p>这样我们定义了类型签名之间的&lt;code>subtyping&lt;/code>关系. 于是我们使用这个&lt;code>compare&lt;/code>关系对一个函数的所有签名进行拓扑排序, 结果将得到一个序列.&lt;/p>
&lt;p>注意这里使用拓扑排序而不是别的排序方法, 是因为签名之间并不是良序关系. 两个签名之间可能其实是没有任何大小关系的(上面的&lt;code>return not comparable&lt;/code>分支). 因此一个函数的所有签名其实构成了多个&lt;code>DAG&lt;/code>(有向无环图).&lt;/p>
&lt;p>按照拓扑排序得到的序列搜索, 一定能够得到&lt;code>最具体&lt;/code>的那个签名.&lt;/p>
&lt;h3 id="加入multiple-subtypes后的变化">加入&lt;code>multiple subtypes&lt;/code>后的变化:&lt;/h3>
&lt;p>上面的定义很不错, 但是没有考虑一种情况: 在&lt;code>tuple of types&lt;/code>的&lt;code>&amp;lt;:&lt;/code>定义中, 我们使用了&lt;code>a &amp;lt;: b&lt;/code>这个比较. 然而当&lt;code>multiple subtypes&lt;/code>存在的时候, &lt;code>a&lt;/code>和&lt;code>b&lt;/code>可能是一个类型, 也可能是一个联合类型&lt;code>[type, type ...]&lt;/code>. 那么如何求&lt;code>a &amp;lt;: b&lt;/code>呢?&lt;/p>
&lt;p>比如, 当&lt;/p>
&lt;pre>&lt;code class="language-python">class A: pass
class B: pass
class C(A, B): pass
&lt;/code>&lt;/pre>
&lt;p>时, 如何证明&lt;code>C &amp;lt;: [A, B]&lt;/code>呢?&lt;/p>
&lt;p>甚至是当&lt;/p>
&lt;pre>&lt;code class="language-python">class A: pass
class B: pass
class C(A): pass
class D(B): pass
&lt;/code>&lt;/pre>
&lt;p>时, 如何证明&lt;code>[C, D] &amp;lt;: [A, B]&lt;/code>呢?&lt;/p>
&lt;p>我们拓展一下&lt;code>subtyping&lt;/code>关系即可:&lt;/p>
&lt;pre>&lt;code>对于types a and b
def a &amp;lt;: b as
if a and b both are type then
return a &amp;lt;: b
else if a is type and b is tuple then
return if a &amp;lt;: all types in b
else if a is tuple and b is type then
return if any types in a &amp;lt;: b
else if a and b both are tuple then
return for all types in b if any types in a &amp;lt;: types in b
&lt;/code>&lt;/pre>
&lt;p>经过这样一个补充定义以后, &lt;code>multipledispatch2&lt;/code>就完美支持&lt;code>multiple subtypes&lt;/code>啦.&lt;/p></description></item><item><title>Python C3 Linearization</title><link>http://wooya.me/post/python-c3-linearization/</link><pubDate>Sat, 09 Apr 2016 17:35:01 +0800</pubDate><guid>http://wooya.me/post/python-c3-linearization/</guid><description>&lt;p>本文讲解了python的方法搜索优先级, &lt;code>super&lt;/code>函数的调用以及python的线性化算法&lt;code>C3&lt;/code>.&lt;/p>
&lt;p>昨天在搞python多继承的时候遇到一个问题抽象化如下:&lt;/p>
&lt;pre>&lt;code class="language-python">class A:
def foo(self):
print(&amp;quot;A&amp;quot;)
class B:
def foo(self):
print(&amp;quot;B&amp;quot;)
super().foo()
class C(B,A):
def foo(self):
print(&amp;quot;C&amp;quot;)
super().foo()
&lt;/code>&lt;/pre>
&lt;p>调用&lt;code>C().foo()&lt;/code>会输出:&lt;/p>
&lt;pre>&lt;code class="language-python">C
B
A
&lt;/code>&lt;/pre>
&lt;p>其中第一行输出&lt;code>C&lt;/code>很好理解, 第二行&lt;code>类B的foo&lt;/code>输出&lt;code>B&lt;/code>以后调用了&lt;code>super&lt;/code>的&lt;code>foo方法&lt;/code>。但是如果&lt;code>B的foo&lt;/code>:&lt;/p>
&lt;ol>
&lt;li>调用了&lt;code>B&lt;/code>的&lt;code>super&lt;/code>, 则因为&lt;code>B&lt;/code>并没有父类, 所以&lt;code>super().foo()&lt;/code>的调用应该会失败，抛出&lt;code>AttributeError&lt;/code>错误。&lt;/li>
&lt;li>调用了&lt;code>self&lt;/code>的&lt;code>super&lt;/code>, 由于此时&lt;code>self&lt;/code>的类型是&lt;code>C&lt;/code>, 那么又会去调用&lt;code>B&lt;/code>的&lt;code>foo&lt;/code>形成无限递归调用.&lt;/li>
&lt;/ol>
&lt;p>然而事实上并没有发生以上两种情况。&lt;code>B&lt;/code>的&lt;code>super&lt;/code>竟然调用了&lt;code>A&lt;/code>的&lt;code>foo&lt;/code>.&lt;/p>
&lt;p>其实个人觉得这里的&lt;code>super&lt;/code>有些误导人, &lt;code>super&lt;/code>并不一定是去寻找父类, 它的意思是: 沿着方法搜索序列(&lt;code>mro&lt;/code>)往上搜索一格。
要理解&lt;code>mro&lt;/code>, 首先需要知道什么是&lt;code>linearization&lt;/code>.&lt;/p>
&lt;p>&lt;code>linearization&lt;/code>一般出现在具有多继承的语言中, 比如scala, python等.
因为多继承必然会带来方法冲突等问题从而导致方法搜索失败, 所以必须规定一个方法搜索顺序防止冲突, 线性的从最底部叶
子类开始向上搜索方法直到找到或失败. 这就要求把一棵继承树变化成一个一维的线性结构.&lt;/p>
&lt;p>在python中线性化的算法是一种叫做&lt;code>C3&lt;/code>的算法. 来自论文
&lt;a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.3910" target="_blank" rel="noopener">A Monotonic Superclass Linearization for Dylan&lt;/a>
.&lt;/p>
&lt;p>它的描述如下(来自wikipedia):&lt;/p>
&lt;blockquote>
&lt;p>对于以下的类型:&lt;/p>
&lt;pre>&lt;code>&lt;/code>&lt;/pre>
&lt;/blockquote>
&lt;p>class O
class A extends O
class B extends O
class C extends O
class D extends O
class E extends O
class K1 extends A, B, C
class K2 extends D, B, E
class K3 extends D, A
class Z extends K1, K2, K3&lt;/p>
&lt;pre>&lt;code>&amp;gt; 他们的线性化(即方法搜索顺序)是:
&amp;gt; ```
L(O) := [O] // the linearization of O is trivially the singleton list [O], because O has no parents
L(A) := [A] + merge(L(O), [O]) // the linearization of A is A plus the merge of its parents' linearizations with the list of parents...
= [A] + merge([O], [O])
= [A, O] // ...which simply prepends A to its single parent's linearization
L(B) := [B, O] // linearizations of B, C, D and E are computed similar to that of A
L(C) := [C, O]
L(D) := [D, O]
L(E) := [E, O]
L(K1) := [K1] + merge(L(A), L(B), L(C), [A, B, C]) // first, find the linearizations of K1's parents, L(A), L(B), and L(C), and merge them with the parent list [A, B, C]
= [K1] + merge([A, O], [B, O], [C, O], [A, B, C]) // class A is a good candidate for the first merge step, because it only appears as the head of the first and last lists
= [K1, A] + merge([O], [B, O], [C, O], [B, C]) // class O is not a good candidate for the next merge step, because it also appears in the tails of list 2 and 3, but...
= [K1, A, B] + merge([O], [O], [C, O], [C]) // ...class B qualified, and so does class C; class O still appears in the tail of list 3
= [K1, A, B, C] + merge([O], [O], [O]) // finally, class O is a valid candidate, which also exhausts all remaining lists
= [K1, A, B, C, O]
L(K2) := [K2] + merge(L(D), L(B), L(E), [D, B, E])
= [K2] + merge([D, O], [B, O], [E, O], [D, B, E]) // select D
= [K2, D] + merge([O], [B, O], [E, O], [B, E]) // fail O, select B
= [K2, D, B] + merge([O], [O], [E, O], [E]) // fail O, select E
= [K2, D, B, E] + merge([O], [O], [O]) // select O
= [K2, D, B, E, O]
L(K3) := [K3] + merge(L(D), L(A), [D, A])
= [K3] + merge([D, O], [A, O], [D, A]) // select D
= [K3, D] + merge([O], [A, O], [A]) // fail O, select A
= [K3, D, A] + merge([O], [O]) // select O
= [K3, D, A, O]
L(Z) := [Z] + merge(L(K1), L(K2), L(K3), [K1, K2, K3])
= [Z] + merge([K1, A, B, C, O], [K2, D, B, E, O], [K3, D, A, O], [K1, K2, K3]) // select K1
= [Z, K1] + merge([A, B, C, O], [K2, D, B, E, O], [K3, D, A, O], [K2, K3]) // fail A, select K2
= [Z, K1, K2] + merge([A, B, C, O], [D, B, E, O], [K3, D, A, O], [K3]) // fail A, fail D, select K3
= [Z, K1, K2, K3] + merge([A, B, C, O], [D, B, E, O], [D, A, O]) // fail A, select D
= [Z, K1, K2, K3, D] + merge([A, B, C, O], [B, E, O], [A, O]) // select A
= [Z, K1, K2, K3, D, A] + merge([B, C, O], [B, E, O], [O]) // select B
= [Z, K1, K2, K3, D, A, B] + merge([C, O], [E, O], [O]) // select C
= [Z, K1, K2, K3, D, A, B, C] + merge([O], [E, O], [O]) // fail O, select E
= [Z, K1, K2, K3, D, A, B, C, E] + merge([O], [O], [O]) // select O
= [Z, K1, K2, K3, D, A, B, C, E, O] // done
&lt;/code>&lt;/pre>
&lt;p>比如要调用&lt;code>Z().foo()&lt;/code>, 然而&lt;code>D&lt;/code>和&lt;code>A&lt;/code>都定义了&lt;code>foo&lt;/code>这个方法, 则根据&lt;code>Z&lt;/code>的线性化&lt;code>L(Z) := [Z, K1, K2, K3, D, A, B, C, E, O]&lt;/code>, 第一个搜索到的&lt;code>foo&lt;/code>应该来自&lt;code>D&lt;/code>。&lt;/p>
&lt;p>这样的话就完美解释了上文第一个例子中为什么&lt;code>B&lt;/code>的&lt;code>super().foo()&lt;/code>调用了&lt;code>A&lt;/code>的&lt;code>foo&lt;/code>:&lt;/p>
&lt;p>&lt;code>super()&lt;/code>其实是&lt;code>super(__class__, self)&lt;/code>的简写, 它的作用是在&lt;code>self&lt;/code>的线性化上排除掉自己以及自己之前的类型.&lt;/p>
&lt;p>比如&lt;code>B&lt;/code>中的&lt;code>super()&lt;/code>其实是&lt;code>super(__class__, self)&lt;/code>就是&lt;code>super(B, self)&lt;/code>. 其中&lt;code>self&lt;/code>为&lt;code>C&lt;/code>.&lt;/p>
&lt;p>比如因为&lt;code>C&lt;/code>线性化为&lt;code>L(C) := [C, B, A]&lt;/code>, &lt;code>C&lt;/code>中调用&lt;code>super&lt;/code>, 在线性化结果上排除自己以及之前的类型，则产生搜索顺序&lt;code>[B, A]&lt;/code>, 所以&lt;code>C&lt;/code>中&lt;code>super().foo()&lt;/code>调用的结果是调用了&lt;code>B&lt;/code>的&lt;code>foo&lt;/code>.&lt;/p>
&lt;p>而在&lt;code>B&lt;/code>中调用&lt;code>super()&lt;/code>排除自己&lt;code>B&lt;/code>以及之前的类型&lt;code>C&lt;/code>, 产生搜索顺序&lt;code>[A]&lt;/code>, 所以&lt;code>B&lt;/code>中&lt;code>super().foo()&lt;/code>调用的结果是调用了&lt;code>A&lt;/code>的&lt;code>foo&lt;/code>.&lt;/p>
&lt;p>这个线性化结果可以通过python的类的&lt;code>mro&lt;/code>方法进行查看。&lt;/p>
&lt;pre>&lt;code class="language-python">C.mro() == [C, B, A]
&lt;/code>&lt;/pre></description></item><item><title>coroutine-rs</title><link>http://wooya.me/project/coroutine-rs/</link><pubDate>Wed, 04 Nov 2015 12:03:11 +0800</pubDate><guid>http://wooya.me/project/coroutine-rs/</guid><description>&lt;p>Coroutine library for Rust! As the cooperator of this project with
&lt;a href="https://github.com/zonyitoo" target="_blank" rel="noopener">Zonyitoo&lt;/a>
.&lt;/p></description></item><item><title>Rust Compiler Plugin</title><link>http://wooya.me/post/rust-compiler-plugin/</link><pubDate>Wed, 04 Nov 2015 11:54:16 +0800</pubDate><guid>http://wooya.me/post/rust-compiler-plugin/</guid><description>&lt;p>rust 提供了一个很强大的编译时功能：自定义编译器插件。&lt;/p>
&lt;p>通过向编译器register一个函数作为入口，它可以在lint时期把ast作为register的那个函数的一个参数来invoke。也就是说，通过编译器插件，我们可以做很多强（wei）大（suo）的事情。&lt;/p>
&lt;ul>
&lt;li>例子1：
&lt;a href="https://github.com/brson/rust-chamber" target="_blank" rel="noopener">rust-chamber&lt;/a>
&lt;/li>
&lt;/ul>
&lt;p>chamber是一个语言级别的sandbox(其实是一个rustc的包装)，可以防止你的语言中出现不安全的code。目前它的功能很简单，一旦发现你的code里面有使用了unsafe，或者开启了编译器feature(#![feature()]),
或者使用了不安全的crate（比如intrinsic）编译就会通不过。怎么实现的呢？其实很简单。下面贴上核心代码：&lt;/p>
&lt;!--more-->
&lt;pre>&lt;code class="language-rust">fn check_expr(&amp;amp;mut self, ctx: &amp;amp;Context, e: &amp;amp;ast::Expr) {
match e.node {
// Don't warn about generated blocks, that'll just pollute the output.
ast::ExprBlock(ref blk) if blk.rules == ast::UnsafeBlock(ast::UserProvided) =&amp;gt; {
ctx.span_lint(CH_UNSAFE_BLOCK, e.span, &amp;quot;chamber: `unsafe` block&amp;quot;);
}
_ =&amp;gt; ()
}
}
&lt;/code>&lt;/pre>
&lt;p>context是用来控制编译器行为的。e是传入的expression的ast表现形式。check_expr的作用就是对每个传入的expression进行判断，如果是unsafe
block，就报错。&lt;/p>
&lt;ul>
&lt;li>例子2：
&lt;a href="https://github.com/huonw/spellck" target="_blank" rel="noopener">spellck&lt;/a>
&lt;/li>
&lt;/ul>
&lt;p>这是一个基于字典的拼写检查插件。通过字典，可以将代码中的单词拼写错误在编译器进行提示。麻麻再也不用担心我在代码里面打错别字啦！&lt;/p>
&lt;ul>
&lt;li>例子3：
&lt;a href="http://static.rust-lang.org/doc/master/regex/index.html" target="_blank" rel="noopener">regex&lt;/a>
&lt;/li>
&lt;/ul>
&lt;p>重量级插件：rust官方正则表达式库。什么？正则表达式和插件有什么关系？
这里说的是rust的regex！宏。众所周知，正则表达式需要进行编译。比如python的re.compile，go的regexp.Compile等等。正则表达式需要在运行时，将一个正则表达式字符串编译成正则表达式虚拟机上的指令。所以正则表达式其实是一个内嵌在语言内部的虚拟机语言。
既然正则表达式在运行时才能够进行编译，并且只是编译成虚拟机指令，那么它的效率必然会比原生代码低很多。那么我们能不能把这个过程提前到编译时呢？正则表达式规则是通过字符串的形式来书写的，在编译时无法确定它的内容（字符串是可变的）。所以在一般的语言中确实做不到编译时处理正则表达式。但是通过rust的编译器插件，我们可以实现对常量字符串表达式进行编译时的正则表达式编译。
regex插件在编译时会把相应的正则表达式编译成rust代码，所以在运行时完全没有用到正则的虚拟机和指令。因此执行速度非常快。但唯一的缺点就是如果生成太多的正则表达式，那么编译出来的二进制文件会变得非常大。（毕竟是吧正则表达式展开成了大量的rust代码。）&lt;/p>
&lt;p>================================================================&lt;/p>
&lt;p>介绍到此为止，下面是教程。
首先，你需要引入一个编译器特性， &lt;code>plugin_registrar&lt;/code>
在代码开头加上
&lt;code>#![feature(phase, plugin_registrar)]&lt;/code>
使用phase特性是因为我们需要一些在rustc里面的宏来帮忙。可以省去一些代码。&lt;/p>
&lt;pre>&lt;code>#[phase(plugin, link)] // Load rustc as a plugin to get lint macros
extern crate rustc;
extern crate syntax;
use rustc::lint::{Context, LintPass, LintArray};
use rustc::plugin::Registry;
use syntax::ast;
&lt;/code>&lt;/pre>
&lt;p>引入一些crate。
phase是一个编译器特性。其中plugin的意思是把crate当作插件插入到当前代码（为了引入其中的macro。因为macro不能像传统变量那样采用use来引入），link的意思是把该crate连接到此文件（crate默认其实有一个link的feature）。
接下来是建立一个lint的属性：&lt;/p>
&lt;pre>&lt;code>pub static mylint: &amp;amp;'static rustc::lint::Lint = &amp;amp;lint_initializer!(mylint, Deny, &amp;quot;abrakadabra&amp;quot;);
&lt;/code>&lt;/pre>
&lt;p>我们把它起名字叫做mylint。默认级别是Deny,
并且把它绑定到了mylint这个static变量上（需要注意的是，Lint变量必须是static的）。描述随便写了点。
其中，lint的级别有四个，分别是Allow,Warn,Deny,Forbid.其中Forbid和Deny的区别在于，如果是Deny，那么在源代码里面，使用者可以通过#[allow(myliny)],#[warn(mylint)]进行lint级别更换。比如从禁止一个特性转变为只是警告（P.S.
那就没用啦！程序员从来不看警告）。但是如果设置为Forbid级别，那么用户就无论如何也没办法改变你的lint级别了。比如上面的例子，chamber里面，作者就使用了Forbid级别。
然后我们新建一个LintPassObject;&lt;/p>
&lt;pre>&lt;code>struct MyLintPass1;
&lt;/code>&lt;/pre>
&lt;p>要成为一个LintPassObject，还需要一个Trait的帮助。&lt;/p>
&lt;pre>&lt;code>impl LintPass for MyLintPass1 {
fn get_lints(&amp;amp;self) -&amp;gt; LintArray {
lint_array!(mylint)
}
}
&lt;/code>&lt;/pre>
&lt;p>我们需要为我们的LintPassObject实现LintPass这个Trait。
LintPass这个Trait有很多方法，但是我们只要实现get_lint这一个就可以了。&lt;code>get_lint&lt;/code>这个方法的含义就是把我们前面建立的那个&lt;code>mylint&lt;/code>这个&lt;code>lint&lt;/code>和我们的&lt;code>LintPassObject&lt;/code>关联起来。&lt;code>lint_array&lt;/code>这个宏的作用就是生成一个&lt;code>static&lt;/code>的&lt;code>lint array&lt;/code>。
然后，最后一件事，就是把我们的&lt;code>LintPassObject&lt;/code>注册进编译器。&lt;/p>
&lt;pre>&lt;code>#[plugin_registrar]
pub fn plugin_registrar(reg: &amp;amp;mut Registry) {
reg.register_lint_pass(box MyLintPass1);
}
&lt;/code>&lt;/pre>
&lt;p>只要在一个函数上面打上&lt;/p>
&lt;pre>&lt;code>#[plugin_registrar]
&lt;/code>&lt;/pre>
&lt;p>就告诉了编译器，下面那个函数，是要cha进你身体里的！
然后我们就完成了一个最简单的编译器插件。把它编译成dylib（注意必须是动态链接库，不能编译成rlib）
在需要使用它的地方写上&lt;/p>
&lt;pre>&lt;code>#![feature(phase)]
#[phase(plugin)] extern crate plugin;
&lt;/code>&lt;/pre>
&lt;p>就ok啦！
于是我们完成了一个什么都不做的编译器插件。&lt;/p>
&lt;p>接下来我们给我们的插件添加点小功能：阻止编译啊哈哈哈！
在这个地方，我们加一个函数实现&lt;/p>
&lt;pre>&lt;code>impl LintPass for MyLintPass1 {
fn get_lints(&amp;amp;self) -&amp;gt; LintArray {
lint_array!(mylint)
}
fn check_crate(&amp;amp;mut self, ctx: &amp;amp;Context, crt: &amp;amp;ast::Crate) {
ctx.lint(mylint, &amp;quot;deliberate fail!&amp;quot;)
}
}
&lt;/code>&lt;/pre>
&lt;p>于是除非你在main函数打标记#[allow(mylint)]否则编译就是通不过啦啦啦&lt;/p></description></item><item><title>Rust Inline ASM</title><link>http://wooya.me/post/rust-inline-asm/</link><pubDate>Wed, 04 Nov 2015 11:53:30 +0800</pubDate><guid>http://wooya.me/post/rust-inline-asm/</guid><description>&lt;p>rust和c/c++一样,可以内联汇编.语法和c/c++的内联汇编大致一样.只有几个细节稍有不同.&lt;/p>
&lt;p>首先,需要开启一个特性 &lt;code>#![feature(asm)]&lt;/code>&lt;/p>
&lt;p>然后在&lt;code>asm!&lt;/code>宏里面写汇编即可.&lt;/p>
&lt;p>格式是:&lt;/p>
&lt;pre>&lt;code>asm!(assembly template
: output operands
: input operands
: clobbers
: options
);
&lt;/code>&lt;/pre>
&lt;p>大致和c/c++相同.其中有几个不同点:&lt;/p>
&lt;p>在最后一段用来声明已经使用过的寄存器的那一段(clobbers)下面还可以跟一段option段.备选项有:&amp;ldquo;intel&amp;quot;表示采用intel汇编而不像c那样用AT&amp;amp;T汇编.&amp;ldquo;volatile&amp;rdquo;,和c里面的&lt;code>__asm__volatile__&lt;/code>一样.&amp;ldquo;alignstack&amp;rdquo;,让编译器自动插入对齐栈的代码(因为有些指令集需要对齐栈,比如SSE指令集).
在填充模版的时候,变量用$0,$1来表示,而不是c的%1,%2来表示.
立即数用&lt;code>$$&lt;/code>表示,&lt;code>$$1&lt;/code>就是1.
寄存器直接用%来表示,%eax表示eax寄存器
模版里面多条指令用分号(;)来分割,而不是c的&amp;rdquo;\r\n&amp;rdquo;
声明clobber的时候直接写&lt;code>eax&lt;/code>,不用像C那样写&lt;code>%eax&lt;/code>
记得&lt;code>asm!&lt;/code>的时候要外面套&lt;code>unsafe&lt;/code>块
intel语法我没有试过.所以无从比较语法区别:(&lt;/p>
&lt;p>下面附上我的一个小例子,用汇编+偏移量来访问数组.&lt;/p>
&lt;pre>&lt;code class="language-rust">#![feature(asm)]
fn main() {asm();}
#[cfg(target_arch = &amp;quot;x86_64&amp;quot;)]
fn asm() {
use std::mem::transmute;
use std::rand::random;
let array: &amp;amp;[u64] = &amp;amp;[random(),random(),random(),random()];
let address = unsafe { transmute::&amp;lt;_, (i64, i64)&amp;gt;(array).0 };
for offset in 0u64..4 {
let ret: u64;
unsafe {
asm!(
r&amp;quot;
mov ($1, $2, 8), %rax;
mov %rax, $0;
&amp;quot;
: &amp;quot;=r&amp;quot;(ret)
: &amp;quot;r&amp;quot;(address), &amp;quot;r&amp;quot;(offset)
: &amp;quot;rax&amp;quot;
:
);
}
println!(&amp;quot;在第{}号位上的元素是{}&amp;quot;, offset, ret);
}
}
&lt;/code>&lt;/pre></description></item><item><title>Rust Enum</title><link>http://wooya.me/post/rust-enum/</link><pubDate>Wed, 04 Nov 2015 11:51:39 +0800</pubDate><guid>http://wooya.me/post/rust-enum/</guid><description>&lt;p>本文通过解析&lt;code>llvm&lt;/code>的&lt;code>ir&lt;/code>来解析rust &lt;code>enum&lt;/code>的内存布局。&lt;/p>
&lt;p>rust的enum差不多是C的&lt;code>enum&lt;/code>和&lt;code>union&lt;/code>类型的混合体。可以写成&lt;/p>
&lt;pre>&lt;code class="language-rust">enum Enum {
AEnum = 0,
BEnum = 1,
CEnum = 2,
} // 类似C的Enum
&lt;/code>&lt;/pre>
&lt;p>也可以&lt;/p>
&lt;pre>&lt;code class="language-rust"> enum Buk {
two_int(int,int),
three_uint(uint,uint,uint),
lonely_f64(f64),
} // 类似union
&lt;/code>&lt;/pre>
&lt;p>甚至&lt;/p>
&lt;pre>&lt;code class="language-rust">enum LinkedListNode&amp;lt;T&amp;gt; {
DataOnly(T),
DataWithNext(T,Box&amp;lt;LinkedListNode&amp;lt;T&amp;gt;&amp;gt;),
}
&lt;/code>&lt;/pre>
&lt;p>总之，利用rust的enum，可以任意的构造想要的抽象数据结构。
在另一些语言中，这种数据结构叫做ADT(algebra data type, 代数数据类型)。&lt;/p>
&lt;p>===============================================&lt;/p>
&lt;ul>
&lt;li>最普通的enum。&lt;/li>
&lt;/ul>
&lt;p>有如下结构：&lt;/p>
&lt;pre>&lt;code class="language-rust">enum simple {
A,B,C,D
}
&lt;/code>&lt;/pre>
&lt;p>在rust编译完以后，完全不会为simple生成任何的数据结构。
&lt;code>let a = A&lt;/code> 只会被rust编译成 &lt;code>let a: i8 = 0&lt;/code>。同理，B就是1i8，C就是2i8.&lt;/p>
&lt;p>同理&lt;/p>
&lt;pre>&lt;code class="language-rust">enum simple {
A = 1,
B = 2,
C = 3,
D = 4,
}
&lt;/code>&lt;/pre>
&lt;p>也只是把&lt;code>let a = 0i8&lt;/code>变成了&lt;code>let a = 1i8&lt;/code>而已。&lt;/p>
&lt;p>match这样一个最简单的enum，rust所做的仅仅只有一个简单的对i8的switch语句。&lt;/p>
&lt;ul>
&lt;li>union like enum&lt;/li>
&lt;/ul>
&lt;p>考虑如下enum：&lt;/p>
&lt;pre>&lt;code class="language-rust">enum simple {
A(i32,i64),
B(u8),
C(f32),
}
&lt;/code>&lt;/pre>
&lt;p>这时，这个enum的llvm内存表示为&lt;code>{ i8, [7 x i8], [1 x i64] }&lt;/code>，用rust来表示就是&lt;code>(i8,i8,i8,i8,i8,i8,i8,i8,i64)&lt;/code>&lt;/p>
&lt;p>一共8个i8，一个i64.
可能会纳闷：怎么会有那么多i8呢？
原因在于：内存对齐。&lt;/p>
&lt;p>首先，enum的标号肯定位于头部，就是第一个i8.因此A还是0，B还是1.
但是和例1不同的是，本例中的enum是带有自定义数据的。所以必须为自定义数据分配空间。
我们来算一下：一共需要1&lt;em>i8（用于标号）+1&lt;/em>i32（A的第一个域）+1&lt;em>64（A的第二个域）。B和C我们就不管了，因为它们的大小都小于A，因此我们可以复用A的内存空间。所以这样一个enum至少需要104个bit。但是由于内存对齐的原因，第一个i8要和后面的i64对齐，所以要补上7个i8，因为7&lt;/em>8+8=64嘛。
补完之后我们发现，那个i32也可以被用来补完的7个i8来表示了（4个i8凑一凑就一个i32了嘛）。于是这个enum就是8个i8+1个i64组成了。&lt;/p>
&lt;p>现在来看看当它们分别是A，B，C时的情况。
当enum是A的时候，它的结构会转换成{i8, i32,
i64}.第一个用于标号，是0.第二个是A的第一个域，i32，i64是第二个域。用于内存对齐的i8被llvm自动藏起来了。完整的表示是{i8,
[3 x i8], i32, i64}，中间3个i8会隐藏掉。
当enum是B的时候，结构就变成了{i8,i8}后面的一大堆东西统统不要。所以如果一个enum要是被这样构造了，每一个B都会浪费大量的空间（空间使用率16/128=12.5%）。对于单片机编程来说要尽量避免这种情况。
当enum是C的时候，结构是{i8,float},[3xi8]同A，会隐藏起来。后面浪费了一个i64.利用率50%，也挺低。&lt;/p>
&lt;ul>
&lt;li>1和2混搭&lt;/li>
&lt;/ul>
&lt;p>如下enum：&lt;/p>
&lt;pre>&lt;code class="language-rust">enum simple {
A(i32,i64),
B(u8),
C(f32),
D,
E
}
&lt;/code>&lt;/pre>
&lt;p>具体情况和union enum差不多。后面两个D和E变成{i8}罢了。&lt;/p>
&lt;ul>
&lt;li>泛型enum&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-rust"> enum simple&amp;lt;T&amp;gt; {
Data(T),
Nil
}
let a = simple::Data::&amp;lt;int&amp;gt;(1);
let b = simple::Nil::&amp;lt;uint&amp;gt;;
&lt;/code>&lt;/pre>
&lt;p>泛型其实只是生成了两份代码，一个叫&lt;code>%&amp;quot;enum.main::simple&amp;lt;[int]&amp;gt;&amp;quot; = type { i8, [7 x i8], [1 x i64] }&lt;/code>，
另一个叫&lt;code>%&amp;quot;enum.main::simple&amp;lt;[uint]&amp;gt;&amp;quot; = type { i8, [7 x i8], [1 x i64] }&lt;/code>，其它无任何差别。&lt;/p>
&lt;ul>
&lt;li>struct variant&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-rust">enum simple {
duck {a: int, b: int},
Nil
}
let a = simple::duck{a:4,b:3};
&lt;/code>&lt;/pre>
&lt;p>和普通的enum一样，只是给duck里面的两个i64起个名字罢了。在ir层面没有任何区别。&lt;/p>
&lt;ul>
&lt;li>#[repr(C)]&lt;/li>
&lt;/ul>
&lt;p>rust还支持把enum的内存表示变为C风格的。&lt;/p>
&lt;pre>&lt;code class="language-rust">#[repr(C)]
enum simple {
a(int),
b,c
}
&lt;/code>&lt;/pre>
&lt;p>这儿的区别在于，头部的标号和内存对齐，全部从i8变成了i32，即C的int。&lt;code>{i32, [1 x i32], i64}&lt;/code>&lt;/p></description></item><item><title>Rust Object</title><link>http://wooya.me/post/rust-object/</link><pubDate>Wed, 04 Nov 2015 11:49:25 +0800</pubDate><guid>http://wooya.me/post/rust-object/</guid><description>&lt;p>rust有非常强大的类型系统。今天我们来说说rust的泛型。&lt;/p>
&lt;p>rust有两种泛型：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>基于&lt;code>static dispatch&lt;/code>的泛型，类似于C++的模板。在编译期进行代码特化（monomorphization），为每一种类型生成一份代码。好处是执行效率高，但是会带来额外的冗余代码，使二进制文件变大（bloat）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>基于&lt;code>dynamic dispatch&lt;/code>的泛型，类似于java和go的&lt;code>interface&lt;/code>。在运行期查找虚表（vtable）来选择执行的方法。好处是使用灵活，但是性能肯定比static dispatch来的差。本篇着重介绍这一种泛型。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr/>
&lt;ul>
&lt;li>Trait Object&lt;/li>
&lt;/ul>
&lt;p>rust的&lt;code>dynamic dispatch&lt;/code>实现都是基于一种叫做&lt;code>trait object&lt;/code>的类型来实现的。先看一个例子：&lt;/p>
&lt;pre>&lt;code class="language-rust"> trait Object {
fn dood(&amp;amp;self) -&amp;gt; int {
1i
}
}
impl Object for int {}
impl Object for uint {}
fn main() {
fn gimme_an_object(i: &amp;amp;Object) {
println!(&amp;quot;{}&amp;quot;, i.dood());
}
gimme_an_object(&amp;amp;2i); // OUTPUT: 1
gimme_an_object(&amp;amp;3u); // OUTPUT: 1
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>gimme_an_object&lt;/code>函数这里发生了什么？
可以看到，&lt;code>gimme_an_object&lt;/code>需要传入一个&amp;amp;Object类型的参数。就是说，&lt;code>gimme_an_object&lt;/code>函数的参数i是一个实现了Object这个trait的引用类型。所以我们无论喂给它了一个&amp;amp;int或一个&amp;amp;uint，它都能完成调用。因为之前的两个&lt;code>impl&lt;/code>已经为&lt;code>uint&lt;/code>类型和&lt;code>int&lt;/code>类型实现了&lt;code>Object&lt;/code>这个&lt;code>trait&lt;/code>。
在这一点上，rust的trait和go的interface很相似。我们只需要传入一个接口，函数就能完成工作，为不用管传入的参数到底是什么类型。
但是这里有一个细节需要注意：为什么要写&lt;code>&amp;amp;Object&lt;/code>，写成&lt;code>fn gimme_an_object(i: Object)&lt;/code>不行吗？
答案是不行。有人可能很奇怪，为什么我在go里面直接写interface就没问起，rust里面却必须要加个引用呢？
原因有两个：&lt;/p>
&lt;ol>
&lt;li>&lt;/li>
&lt;/ol>
&lt;p>因为按照rust的设计用途，它可以做底层开发，也可以做上层开发。因此内存布局要尽可能的”raw“。所有的数据都是赤裸裸的躺在堆上或栈上。因此一个Object的大小是不确定的。比如你可以为一个i8实现Object，再为一个u64实现Object。它们都能被当错参数传进&lt;code>gimme_an_object&lt;/code>，但是显然他们的大小是不一样的（不考虑内存对齐）。对于动态长度的类型，显然没法在栈上分配空间，因为他们是编译时位置长度的。所以要用一个指针指向某个实现了trait的对象。因为指针是编译时大小已知的。
同理，像go、java也不可能绕过这个限制，毕竟他们不是黑魔法。之所以他们能直接写&lt;code>func(i interface{})&lt;/code>的原因，是因为它们的interface自己就是一个指针。他们没有写嵌入式的负担，又有GC的照顾，自然可以肆无忌惮的用指针来指向一个类型并且把一切都隐藏起来就好像interface里的数据真真切切就在那儿一样。其实只是个indirection而已。
2. rust有三种原生指针，&amp;amp;、Box和*。无论哪一种都可以作为trait
object的indirection，因此要是用interface一统江湖，不再写&amp;amp;，必然导致灵活性下降。无论用哪一种作为trait&lt;br>
object的默认指针都有失偏颇。&lt;/p>
&lt;ul>
&lt;li>trait object的编译器魔法。&lt;/li>
&lt;/ul>
&lt;p>在rust里，所有的指针都是一个字长。比如64位机器上，&amp;amp;1i的大小就是64个bit。
但是在trait object中，rust编译器会隐式的把指针转换为一个胖指针。&lt;/p>
&lt;pre>&lt;code class="language-rust"> // in core::raw::TraitObject
struct TraitObject {
data: *mut (),
vtable: *mut (),
}
&lt;/code>&lt;/pre>
&lt;p>也就是说，所有的TraitObject大小其实都是两个字长。第一个指向数据，第二个指向虚函数表。这点和go的interface其实是一模一样的。&lt;/p>
&lt;ul>
&lt;li>trait safety&lt;/li>
&lt;/ul>
&lt;p>对于trait object，rust还有一个限制：只有safe的trait才能被用作trait object。
什么叫safe的trait呢？
因为有些trait会返回一个self类型，比如：&lt;/p>
&lt;pre>&lt;code class="language-rust"> trait RetSelf {
fn ret_self(&amp;amp;self) -&amp;gt; Self;
}
&lt;/code>&lt;/pre>
&lt;p>如果impl给了int，那么ret_self方法的返回值就是一个int，要是impl给了f64，那么返回值就是一个f64.这就意味着代码诸如：&lt;/p>
&lt;pre>&lt;code class="language-rust"> fn unsafe_object(i: &amp;amp;RetSelf) {
let c = i.ret_self();
}
&lt;/code>&lt;/pre>
&lt;p>是无法编译的，因为无从知道c的大小。因此在rust里面，只有不带有fn() -&amp;gt;
Self类型的方法的trait才叫safe的trait，只有safe的trait才能被用作trait object。这也是为什么rust有很多trait xxxx，
trait XXXXEXT。因为XXXX是safe的object，而trait
XXXXEXT里面包含了带有返回Self的方法。如果把两者合并为同一个trait，意味着trait XXXX将不能再用于trait
object。因此必须用两个trait来吧unsafe的方法隔离开。比如常用的Iterator
trait就是如此。它从以前的一个trait变成了如今的interator和iteratorExt.&lt;/p></description></item><item><title>Talk About Phantom Type</title><link>http://wooya.me/post/rust-phantom-type/</link><pubDate>Mon, 02 Nov 2015 10:36:23 +0800</pubDate><guid>http://wooya.me/post/rust-phantom-type/</guid><description>&lt;p>在具有高级类型系统的语言里面，有一种类型标记的用法叫phantom type,
比如
&lt;a href="http://www.haskell.org/haskellwiki/Phantom_type" target="_blank" rel="noopener">Haskell语言&lt;/a>
。这种用法有个很有意思用途：用来做编译时的类型检查，并且对于编译后的代码来说，完全没有任何的副作用。&lt;/p>
&lt;p>举个例子，在做几何运算的时候，我们会碰到运算时变量单位的问题。&lt;/p>
&lt;pre>&lt;code class="language-rust">#[deriving(Show)]
struct Length&amp;lt;Num&amp;gt;(Num);
type Meter = f64;
type Inch = f64;
let a: Length&amp;lt;Meter&amp;gt; = Length(5.0 as Meter);
let b: Length&amp;lt;Inch&amp;gt; = Length(7.0 as Inch);
impl&amp;lt;Num&amp;gt; Add&amp;lt;Length&amp;lt;Num&amp;gt;,Length&amp;lt;Num&amp;gt;&amp;gt; for Length&amp;lt;Num&amp;gt; where Num: Add&amp;lt;Num,Num&amp;gt; {
fn add(self, rhs: Length&amp;lt;Num&amp;gt;) -&amp;gt; Length&amp;lt;Num&amp;gt; {
Length(self.0 + rhs.0)
}
}
println!(&amp;quot;{}&amp;quot;, a + b);
&lt;/code>&lt;/pre>
&lt;p>在上面的代码中，我们有一个很明显的bug,单位为米的a竟然和单位为英寸的b进行了相加。要是在业务逻辑中出现这么一茬，肯定很难debug，因为从语法上来讲，完全没有问题啊！&lt;/p>
&lt;p>现在我们来引入一种类型系统的trick，叫做phantom type。&lt;/p>
&lt;pre>&lt;code class="language-rust">mod unit {
#[deriving(Show)]
enum Meter {}
#[deriving(Show)]
enum Inch {}
}
#[deriving(Show)]
struct Length&amp;lt;Unit,Num&amp;gt;(Num);
let a: Length&amp;lt;unit::Meter,f64&amp;gt; = Length(5.0);
let b: Length&amp;lt;unit::Inch,f64&amp;gt; = Length(7.0);
impl&amp;lt;Unit,Num&amp;gt; Add&amp;lt;Length&amp;lt;Unit,Num&amp;gt;,Length&amp;lt;Unit,Num&amp;gt;&amp;gt; for Length&amp;lt;Unit,Num&amp;gt; where Num: Add&amp;lt;Num,Num&amp;gt; {
fn add(self, rhs: Length&amp;lt;Unit,Num&amp;gt;) -&amp;gt; Length&amp;lt;Unit,Num&amp;gt; {
Length(self.0 + rhs.0)
}
}
println!(&amp;quot;{}&amp;quot;, a + b);
&lt;/code>&lt;/pre>
&lt;p>为了打印方便，加了一些&lt;code>#[deriving(Show)]&lt;/code>。 我们给Length类型加上了一个&lt;code>Unit &lt;/code>的类型标记。但是，Unit却没有出现在任何有值的地方，它仅仅是作为了一个类型标记存在着。所以，我想这也是为什么它叫&lt;code>phantom type&lt;/code>的原因吧。&lt;/p>
&lt;p>编译上面那段的代码，编译器会给你报错：&lt;/p>
&lt;pre>&lt;code class="language-rust">error: mismatched types: expected `main::Length&amp;lt;main::unit::Meter, f64&amp;gt;`, found `main::Length&amp;lt;main::unit::Inch,
f64&amp;gt;` (expected enum main::unit::Meter,found enum main::unit::Inch)
&lt;/code>&lt;/pre>
&lt;p>编译器说： a是&lt;code>Length&amp;lt;Meter,f64&amp;gt;&lt;/code>, b是&lt;code>&amp;lt;Inch，f64&amp;gt;&lt;/code>,它们类型不相容。&lt;/p>
&lt;p>仅仅通过增加一个额外的类型标记，我们就实现了让编译器自动给我们检查单位的方法，而且这种&lt;code>phantom type&lt;/code>的小trick，不会带来任何的运行时负担。在编译完毕后，它们就被一并的擦除了。&lt;/p>
&lt;p>其实这是一种对现实中单位制的模拟。平时我们写的时候一般写
1m，2mm之类。其实当我们写下了1m这个数字的时候，其实着我们写下了两个东西，作为数字的1和作为单位的m。单独拿出来，对于数字1来讲，他没有任何的意义。可以随便对他加上其它的数字；对于m来说，它仅仅是个单位，同样也没有意义。但是1m结合起来，m就为1赋予了class信息，改变了它的运算规则。&lt;code>phantom type&lt;/code>在此，就起到了这个量纲作用。&lt;/p>
&lt;p>除了用来作为数字的单位以外，还有一个比较好用的地方是作为用户输入安全性的标记（这和rust着重安全是遥相呼应啊）。
众所周知，web安全有很大一部分问题，是因为没有对用户输入做检查。一个安全的系统应该对于所有的用户输入采取不信任的态度，应该由代码对其进行检查。
但是在开发的时候，可能由于程序员水平问题，或者一时疏忽等原因，往往会忘记检查。这就为系统埋下了很大的隐患。
利用&lt;code>phantom type&lt;/code>我们可以为所有的string打上tag，让编译器来替我们进行检查。&lt;/p>
&lt;pre>&lt;code class="language-rust">enum Trusted {}
enum UnTrusted {}
struct UserInput&amp;lt;T&amp;gt;(String);
let a: UserInput&amp;lt;Trusted&amp;gt;(&amp;quot;safe&amp;quot;.to_string());
let b: UserInput&amp;lt;UnTrusted&amp;gt;(&amp;quot;SQL Injectiong is here!!!&amp;quot;.to_string());
insert_into_database(a);
insert_into_database(b); // 编译通不过
&lt;/code>&lt;/pre>
&lt;p>假定我们的&lt;code>insert_into_database&lt;/code>接受一个&lt;code>UserInput&amp;lt;Trusted&amp;gt;&lt;/code>作为输入。那么那个b，我们是无论如何也无法存入数据库的，必须要我们进行显式的检查，将其转换为UserInput&lt;Trusted>,否则编译必定报错。这样系统的安全性就大大的加强了。&lt;/p></description></item></channel></rss>