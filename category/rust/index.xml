<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>rust | Ya!</title><link>https://wooya.me/category/rust/</link><atom:link href="https://wooya.me/category/rust/index.xml" rel="self" type="application/rss+xml"/><description>rust</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>© 2022 Weiyuan</copyright><lastBuildDate>Wed, 04 Nov 2015 11:54:16 +0800</lastBuildDate><image><url>https://wooya.me/media/icon_hua2ec155b4296a9c9791d015323e16eb5_11927_512x512_fill_lanczos_center_3.png</url><title>rust</title><link>https://wooya.me/category/rust/</link></image><item><title>Rust Compiler Plugin</title><link>https://wooya.me/post/rust-compiler-plugin/</link><pubDate>Wed, 04 Nov 2015 11:54:16 +0800</pubDate><guid>https://wooya.me/post/rust-compiler-plugin/</guid><description>&lt;p>rust 提供了一个很强大的编译时功能：自定义编译器插件。&lt;/p>
&lt;p>通过向编译器register一个函数作为入口，它可以在lint时期把ast作为register的那个函数的一个参数来invoke。也就是说，通过编译器插件，我们可以做很多强（wei）大（suo）的事情。&lt;/p>
&lt;ul>
&lt;li>例子1：&lt;a href="https://github.com/brson/rust-chamber" target="_blank" rel="noopener">rust-chamber&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>chamber是一个语言级别的sandbox(其实是一个rustc的包装)，可以防止你的语言中出现不安全的code。目前它的功能很简单，一旦发现你的code里面有使用了unsafe，或者开启了编译器feature(#![feature()]),
或者使用了不安全的crate（比如intrinsic）编译就会通不过。怎么实现的呢？其实很简单。下面贴上核心代码：&lt;/p>
&lt;!--more-->
&lt;pre>&lt;code class="language-rust">fn check_expr(&amp;amp;mut self, ctx: &amp;amp;Context, e: &amp;amp;ast::Expr) {
match e.node {
// Don't warn about generated blocks, that'll just pollute the output.
ast::ExprBlock(ref blk) if blk.rules == ast::UnsafeBlock(ast::UserProvided) =&amp;gt; {
ctx.span_lint(CH_UNSAFE_BLOCK, e.span, &amp;quot;chamber: `unsafe` block&amp;quot;);
}
_ =&amp;gt; ()
}
}
&lt;/code>&lt;/pre>
&lt;p>context是用来控制编译器行为的。e是传入的expression的ast表现形式。check_expr的作用就是对每个传入的expression进行判断，如果是unsafe
block，就报错。&lt;/p>
&lt;ul>
&lt;li>例子2：&lt;a href="https://github.com/huonw/spellck" target="_blank" rel="noopener">spellck&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>这是一个基于字典的拼写检查插件。通过字典，可以将代码中的单词拼写错误在编译器进行提示。麻麻再也不用担心我在代码里面打错别字啦！&lt;/p>
&lt;ul>
&lt;li>例子3：&lt;a href="http://static.rust-lang.org/doc/master/regex/index.html" target="_blank" rel="noopener">regex&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>重量级插件：rust官方正则表达式库。什么？正则表达式和插件有什么关系？
这里说的是rust的regex！宏。众所周知，正则表达式需要进行编译。比如python的re.compile，go的regexp.Compile等等。正则表达式需要在运行时，将一个正则表达式字符串编译成正则表达式虚拟机上的指令。所以正则表达式其实是一个内嵌在语言内部的虚拟机语言。
既然正则表达式在运行时才能够进行编译，并且只是编译成虚拟机指令，那么它的效率必然会比原生代码低很多。那么我们能不能把这个过程提前到编译时呢？正则表达式规则是通过字符串的形式来书写的，在编译时无法确定它的内容（字符串是可变的）。所以在一般的语言中确实做不到编译时处理正则表达式。但是通过rust的编译器插件，我们可以实现对常量字符串表达式进行编译时的正则表达式编译。
regex插件在编译时会把相应的正则表达式编译成rust代码，所以在运行时完全没有用到正则的虚拟机和指令。因此执行速度非常快。但唯一的缺点就是如果生成太多的正则表达式，那么编译出来的二进制文件会变得非常大。（毕竟是吧正则表达式展开成了大量的rust代码。）&lt;/p>
&lt;p>================================================================&lt;/p>
&lt;p>介绍到此为止，下面是教程。
首先，你需要引入一个编译器特性， &lt;code>plugin_registrar&lt;/code>
在代码开头加上
&lt;code>#![feature(phase, plugin_registrar)]&lt;/code>
使用phase特性是因为我们需要一些在rustc里面的宏来帮忙。可以省去一些代码。&lt;/p>
&lt;pre>&lt;code>#[phase(plugin, link)] // Load rustc as a plugin to get lint macros
extern crate rustc;
extern crate syntax;
use rustc::lint::{Context, LintPass, LintArray};
use rustc::plugin::Registry;
use syntax::ast;
&lt;/code>&lt;/pre>
&lt;p>引入一些crate。
phase是一个编译器特性。其中plugin的意思是把crate当作插件插入到当前代码（为了引入其中的macro。因为macro不能像传统变量那样采用use来引入），link的意思是把该crate连接到此文件（crate默认其实有一个link的feature）。
接下来是建立一个lint的属性：&lt;/p>
&lt;pre>&lt;code>pub static mylint: &amp;amp;'static rustc::lint::Lint = &amp;amp;lint_initializer!(mylint, Deny, &amp;quot;abrakadabra&amp;quot;);
&lt;/code>&lt;/pre>
&lt;p>我们把它起名字叫做mylint。默认级别是Deny,
并且把它绑定到了mylint这个static变量上（需要注意的是，Lint变量必须是static的）。描述随便写了点。
其中，lint的级别有四个，分别是Allow,Warn,Deny,Forbid.其中Forbid和Deny的区别在于，如果是Deny，那么在源代码里面，使用者可以通过#[allow(myliny)],#[warn(mylint)]进行lint级别更换。比如从禁止一个特性转变为只是警告（P.S.
那就没用啦！程序员从来不看警告）。但是如果设置为Forbid级别，那么用户就无论如何也没办法改变你的lint级别了。比如上面的例子，chamber里面，作者就使用了Forbid级别。
然后我们新建一个LintPassObject;&lt;/p>
&lt;pre>&lt;code>struct MyLintPass1;
&lt;/code>&lt;/pre>
&lt;p>要成为一个LintPassObject，还需要一个Trait的帮助。&lt;/p>
&lt;pre>&lt;code>impl LintPass for MyLintPass1 {
fn get_lints(&amp;amp;self) -&amp;gt; LintArray {
lint_array!(mylint)
}
}
&lt;/code>&lt;/pre>
&lt;p>我们需要为我们的LintPassObject实现LintPass这个Trait。
LintPass这个Trait有很多方法，但是我们只要实现get_lint这一个就可以了。&lt;code>get_lint&lt;/code>这个方法的含义就是把我们前面建立的那个&lt;code>mylint&lt;/code>这个&lt;code>lint&lt;/code>和我们的&lt;code>LintPassObject&lt;/code>关联起来。&lt;code>lint_array&lt;/code>这个宏的作用就是生成一个&lt;code>static&lt;/code>的&lt;code>lint array&lt;/code>。
然后，最后一件事，就是把我们的&lt;code>LintPassObject&lt;/code>注册进编译器。&lt;/p>
&lt;pre>&lt;code>#[plugin_registrar]
pub fn plugin_registrar(reg: &amp;amp;mut Registry) {
reg.register_lint_pass(box MyLintPass1);
}
&lt;/code>&lt;/pre>
&lt;p>只要在一个函数上面打上&lt;/p>
&lt;pre>&lt;code>#[plugin_registrar]
&lt;/code>&lt;/pre>
&lt;p>就告诉了编译器，下面那个函数，是要cha进你身体里的！
然后我们就完成了一个最简单的编译器插件。把它编译成dylib（注意必须是动态链接库，不能编译成rlib）
在需要使用它的地方写上&lt;/p>
&lt;pre>&lt;code>#![feature(phase)]
#[phase(plugin)] extern crate plugin;
&lt;/code>&lt;/pre>
&lt;p>就ok啦！
于是我们完成了一个什么都不做的编译器插件。&lt;/p>
&lt;p>接下来我们给我们的插件添加点小功能：阻止编译啊哈哈哈！
在这个地方，我们加一个函数实现&lt;/p>
&lt;pre>&lt;code>impl LintPass for MyLintPass1 {
fn get_lints(&amp;amp;self) -&amp;gt; LintArray {
lint_array!(mylint)
}
fn check_crate(&amp;amp;mut self, ctx: &amp;amp;Context, crt: &amp;amp;ast::Crate) {
ctx.lint(mylint, &amp;quot;deliberate fail!&amp;quot;)
}
}
&lt;/code>&lt;/pre>
&lt;p>于是除非你在main函数打标记#[allow(mylint)]否则编译就是通不过啦啦啦&lt;/p></description></item><item><title>Rust Inline ASM</title><link>https://wooya.me/post/rust-inline-asm/</link><pubDate>Wed, 04 Nov 2015 11:53:30 +0800</pubDate><guid>https://wooya.me/post/rust-inline-asm/</guid><description>&lt;p>rust和c/c++一样,可以内联汇编.语法和c/c++的内联汇编大致一样.只有几个细节稍有不同.&lt;/p>
&lt;p>首先,需要开启一个特性 &lt;code>#![feature(asm)]&lt;/code>&lt;/p>
&lt;p>然后在&lt;code>asm!&lt;/code>宏里面写汇编即可.&lt;/p>
&lt;p>格式是:&lt;/p>
&lt;pre>&lt;code>asm!(assembly template
: output operands
: input operands
: clobbers
: options
);
&lt;/code>&lt;/pre>
&lt;p>大致和c/c++相同.其中有几个不同点:&lt;/p>
&lt;p>在最后一段用来声明已经使用过的寄存器的那一段(clobbers)下面还可以跟一段option段.备选项有:&amp;ldquo;intel&amp;quot;表示采用intel汇编而不像c那样用AT&amp;amp;T汇编.&amp;ldquo;volatile&amp;rdquo;,和c里面的&lt;code>__asm__volatile__&lt;/code>一样.&amp;ldquo;alignstack&amp;rdquo;,让编译器自动插入对齐栈的代码(因为有些指令集需要对齐栈,比如SSE指令集).
在填充模版的时候,变量用$0,$1来表示,而不是c的%1,%2来表示.
立即数用&lt;code>$$&lt;/code>表示,&lt;code>$$1&lt;/code>就是1.
寄存器直接用%来表示,%eax表示eax寄存器
模版里面多条指令用分号(;)来分割,而不是c的&amp;rdquo;\r\n&amp;quot;
声明clobber的时候直接写&lt;code>eax&lt;/code>,不用像C那样写&lt;code>%eax&lt;/code>
记得&lt;code>asm!&lt;/code>的时候要外面套&lt;code>unsafe&lt;/code>块
intel语法我没有试过.所以无从比较语法区别:(&lt;/p>
&lt;p>下面附上我的一个小例子,用汇编+偏移量来访问数组.&lt;/p>
&lt;pre>&lt;code class="language-rust">#![feature(asm)]
fn main() {asm();}
#[cfg(target_arch = &amp;quot;x86_64&amp;quot;)]
fn asm() {
use std::mem::transmute;
use std::rand::random;
let array: &amp;amp;[u64] = &amp;amp;[random(),random(),random(),random()];
let address = unsafe { transmute::&amp;lt;_, (i64, i64)&amp;gt;(array).0 };
for offset in 0u64..4 {
let ret: u64;
unsafe {
asm!(
r&amp;quot;
mov ($1, $2, 8), %rax;
mov %rax, $0;
&amp;quot;
: &amp;quot;=r&amp;quot;(ret)
: &amp;quot;r&amp;quot;(address), &amp;quot;r&amp;quot;(offset)
: &amp;quot;rax&amp;quot;
:
);
}
println!(&amp;quot;在第{}号位上的元素是{}&amp;quot;, offset, ret);
}
}
&lt;/code>&lt;/pre></description></item><item><title>Rust Enum</title><link>https://wooya.me/post/rust-enum/</link><pubDate>Wed, 04 Nov 2015 11:51:39 +0800</pubDate><guid>https://wooya.me/post/rust-enum/</guid><description>&lt;p>本文通过解析&lt;code>llvm&lt;/code>的&lt;code>ir&lt;/code>来解析rust &lt;code>enum&lt;/code>的内存布局。&lt;/p>
&lt;p>rust的enum差不多是C的&lt;code>enum&lt;/code>和&lt;code>union&lt;/code>类型的混合体。可以写成&lt;/p>
&lt;pre>&lt;code class="language-rust">enum Enum {
AEnum = 0,
BEnum = 1,
CEnum = 2,
} // 类似C的Enum
&lt;/code>&lt;/pre>
&lt;p>也可以&lt;/p>
&lt;pre>&lt;code class="language-rust"> enum Buk {
two_int(int,int),
three_uint(uint,uint,uint),
lonely_f64(f64),
} // 类似union
&lt;/code>&lt;/pre>
&lt;p>甚至&lt;/p>
&lt;pre>&lt;code class="language-rust">enum LinkedListNode&amp;lt;T&amp;gt; {
DataOnly(T),
DataWithNext(T,Box&amp;lt;LinkedListNode&amp;lt;T&amp;gt;&amp;gt;),
}
&lt;/code>&lt;/pre>
&lt;p>总之，利用rust的enum，可以任意的构造想要的抽象数据结构。
在另一些语言中，这种数据结构叫做ADT(algebra data type, 代数数据类型)。&lt;/p>
&lt;p>===============================================&lt;/p>
&lt;ul>
&lt;li>最普通的enum。&lt;/li>
&lt;/ul>
&lt;p>有如下结构：&lt;/p>
&lt;pre>&lt;code class="language-rust">enum simple {
A,B,C,D
}
&lt;/code>&lt;/pre>
&lt;p>在rust编译完以后，完全不会为simple生成任何的数据结构。
&lt;code>let a = A&lt;/code> 只会被rust编译成 &lt;code>let a: i8 = 0&lt;/code>。同理，B就是1i8，C就是2i8.&lt;/p>
&lt;p>同理&lt;/p>
&lt;pre>&lt;code class="language-rust">enum simple {
A = 1,
B = 2,
C = 3,
D = 4,
}
&lt;/code>&lt;/pre>
&lt;p>也只是把&lt;code>let a = 0i8&lt;/code>变成了&lt;code>let a = 1i8&lt;/code>而已。&lt;/p>
&lt;p>match这样一个最简单的enum，rust所做的仅仅只有一个简单的对i8的switch语句。&lt;/p>
&lt;ul>
&lt;li>union like enum&lt;/li>
&lt;/ul>
&lt;p>考虑如下enum：&lt;/p>
&lt;pre>&lt;code class="language-rust">enum simple {
A(i32,i64),
B(u8),
C(f32),
}
&lt;/code>&lt;/pre>
&lt;p>这时，这个enum的llvm内存表示为&lt;code>{ i8, [7 x i8], [1 x i64] }&lt;/code>，用rust来表示就是&lt;code>(i8,i8,i8,i8,i8,i8,i8,i8,i64)&lt;/code>&lt;/p>
&lt;p>一共8个i8，一个i64.
可能会纳闷：怎么会有那么多i8呢？
原因在于：内存对齐。&lt;/p>
&lt;p>首先，enum的标号肯定位于头部，就是第一个i8.因此A还是0，B还是1.
但是和例1不同的是，本例中的enum是带有自定义数据的。所以必须为自定义数据分配空间。
我们来算一下：一共需要1&lt;em>i8（用于标号）+1&lt;/em>i32（A的第一个域）+1&lt;em>64（A的第二个域）。B和C我们就不管了，因为它们的大小都小于A，因此我们可以复用A的内存空间。所以这样一个enum至少需要104个bit。但是由于内存对齐的原因，第一个i8要和后面的i64对齐，所以要补上7个i8，因为7&lt;/em>8+8=64嘛。
补完之后我们发现，那个i32也可以被用来补完的7个i8来表示了（4个i8凑一凑就一个i32了嘛）。于是这个enum就是8个i8+1个i64组成了。&lt;/p>
&lt;p>现在来看看当它们分别是A，B，C时的情况。
当enum是A的时候，它的结构会转换成{i8, i32,
i64}.第一个用于标号，是0.第二个是A的第一个域，i32，i64是第二个域。用于内存对齐的i8被llvm自动藏起来了。完整的表示是{i8,
[3 x i8], i32, i64}，中间3个i8会隐藏掉。
当enum是B的时候，结构就变成了{i8,i8}后面的一大堆东西统统不要。所以如果一个enum要是被这样构造了，每一个B都会浪费大量的空间（空间使用率16/128=12.5%）。对于单片机编程来说要尽量避免这种情况。
当enum是C的时候，结构是{i8,float},[3xi8]同A，会隐藏起来。后面浪费了一个i64.利用率50%，也挺低。&lt;/p>
&lt;ul>
&lt;li>1和2混搭&lt;/li>
&lt;/ul>
&lt;p>如下enum：&lt;/p>
&lt;pre>&lt;code class="language-rust">enum simple {
A(i32,i64),
B(u8),
C(f32),
D,
E
}
&lt;/code>&lt;/pre>
&lt;p>具体情况和union enum差不多。后面两个D和E变成{i8}罢了。&lt;/p>
&lt;ul>
&lt;li>泛型enum&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-rust"> enum simple&amp;lt;T&amp;gt; {
Data(T),
Nil
}
let a = simple::Data::&amp;lt;int&amp;gt;(1);
let b = simple::Nil::&amp;lt;uint&amp;gt;;
&lt;/code>&lt;/pre>
&lt;p>泛型其实只是生成了两份代码，一个叫&lt;code>%&amp;quot;enum.main::simple&amp;lt;[int]&amp;gt;&amp;quot; = type { i8, [7 x i8], [1 x i64] }&lt;/code>，
另一个叫&lt;code>%&amp;quot;enum.main::simple&amp;lt;[uint]&amp;gt;&amp;quot; = type { i8, [7 x i8], [1 x i64] }&lt;/code>，其它无任何差别。&lt;/p>
&lt;ul>
&lt;li>struct variant&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-rust">enum simple {
duck {a: int, b: int},
Nil
}
let a = simple::duck{a:4,b:3};
&lt;/code>&lt;/pre>
&lt;p>和普通的enum一样，只是给duck里面的两个i64起个名字罢了。在ir层面没有任何区别。&lt;/p>
&lt;ul>
&lt;li>#[repr(C)]&lt;/li>
&lt;/ul>
&lt;p>rust还支持把enum的内存表示变为C风格的。&lt;/p>
&lt;pre>&lt;code class="language-rust">#[repr(C)]
enum simple {
a(int),
b,c
}
&lt;/code>&lt;/pre>
&lt;p>这儿的区别在于，头部的标号和内存对齐，全部从i8变成了i32，即C的int。&lt;code>{i32, [1 x i32], i64}&lt;/code>&lt;/p></description></item><item><title>Rust Object</title><link>https://wooya.me/post/rust-object/</link><pubDate>Wed, 04 Nov 2015 11:49:25 +0800</pubDate><guid>https://wooya.me/post/rust-object/</guid><description>&lt;p>rust有非常强大的类型系统。今天我们来说说rust的泛型。&lt;/p>
&lt;p>rust有两种泛型：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>基于&lt;code>static dispatch&lt;/code>的泛型，类似于C++的模板。在编译期进行代码特化（monomorphization），为每一种类型生成一份代码。好处是执行效率高，但是会带来额外的冗余代码，使二进制文件变大（bloat）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>基于&lt;code>dynamic dispatch&lt;/code>的泛型，类似于java和go的&lt;code>interface&lt;/code>。在运行期查找虚表（vtable）来选择执行的方法。好处是使用灵活，但是性能肯定比static dispatch来的差。本篇着重介绍这一种泛型。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr/>
&lt;ul>
&lt;li>Trait Object&lt;/li>
&lt;/ul>
&lt;p>rust的&lt;code>dynamic dispatch&lt;/code>实现都是基于一种叫做&lt;code>trait object&lt;/code>的类型来实现的。先看一个例子：&lt;/p>
&lt;pre>&lt;code class="language-rust"> trait Object {
fn dood(&amp;amp;self) -&amp;gt; int {
1i
}
}
impl Object for int {}
impl Object for uint {}
fn main() {
fn gimme_an_object(i: &amp;amp;Object) {
println!(&amp;quot;{}&amp;quot;, i.dood());
}
gimme_an_object(&amp;amp;2i); // OUTPUT: 1
gimme_an_object(&amp;amp;3u); // OUTPUT: 1
}
&lt;/code>&lt;/pre>
&lt;p>&lt;code>gimme_an_object&lt;/code>函数这里发生了什么？
可以看到，&lt;code>gimme_an_object&lt;/code>需要传入一个&amp;amp;Object类型的参数。就是说，&lt;code>gimme_an_object&lt;/code>函数的参数i是一个实现了Object这个trait的引用类型。所以我们无论喂给它了一个&amp;amp;int或一个&amp;amp;uint，它都能完成调用。因为之前的两个&lt;code>impl&lt;/code>已经为&lt;code>uint&lt;/code>类型和&lt;code>int&lt;/code>类型实现了&lt;code>Object&lt;/code>这个&lt;code>trait&lt;/code>。
在这一点上，rust的trait和go的interface很相似。我们只需要传入一个接口，函数就能完成工作，为不用管传入的参数到底是什么类型。
但是这里有一个细节需要注意：为什么要写&lt;code>&amp;amp;Object&lt;/code>，写成&lt;code>fn gimme_an_object(i: Object)&lt;/code>不行吗？
答案是不行。有人可能很奇怪，为什么我在go里面直接写interface就没问起，rust里面却必须要加个引用呢？
原因有两个：&lt;/p>
&lt;ol>
&lt;li>&lt;/li>
&lt;li>rust有三种原生指针，&amp;amp;、Box和*。无论哪一种都可以作为trait
object的indirection，因此要是用interface一统江湖，不再写&amp;amp;，必然导致灵活性下降。无论用哪一种作为trait&lt;br>
object的默认指针都有失偏颇。&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>trait object的编译器魔法。&lt;/li>
&lt;/ul>
&lt;p>在rust里，所有的指针都是一个字长。比如64位机器上，&amp;amp;1i的大小就是64个bit。
但是在trait object中，rust编译器会隐式的把指针转换为一个胖指针。&lt;/p>
&lt;pre>&lt;code class="language-rust"> // in core::raw::TraitObject
struct TraitObject {
data: *mut (),
vtable: *mut (),
}
&lt;/code>&lt;/pre>
&lt;p>也就是说，所有的TraitObject大小其实都是两个字长。第一个指向数据，第二个指向虚函数表。这点和go的interface其实是一模一样的。&lt;/p>
&lt;ul>
&lt;li>trait safety&lt;/li>
&lt;/ul>
&lt;p>对于trait object，rust还有一个限制：只有safe的trait才能被用作trait object。
什么叫safe的trait呢？
因为有些trait会返回一个self类型，比如：&lt;/p>
&lt;pre>&lt;code class="language-rust"> trait RetSelf {
fn ret_self(&amp;amp;self) -&amp;gt; Self;
}
&lt;/code>&lt;/pre>
&lt;p>如果impl给了int，那么ret_self方法的返回值就是一个int，要是impl给了f64，那么返回值就是一个f64.这就意味着代码诸如：&lt;/p>
&lt;pre>&lt;code class="language-rust"> fn unsafe_object(i: &amp;amp;RetSelf) {
let c = i.ret_self();
}
&lt;/code>&lt;/pre>
&lt;p>是无法编译的，因为无从知道c的大小。因此在rust里面，只有不带有fn() -&amp;gt;
Self类型的方法的trait才叫safe的trait，只有safe的trait才能被用作trait object。这也是为什么rust有很多trait xxxx，
trait XXXXEXT。因为XXXX是safe的object，而trait
XXXXEXT里面包含了带有返回Self的方法。如果把两者合并为同一个trait，意味着trait XXXX将不能再用于trait
object。因此必须用两个trait来吧unsafe的方法隔离开。比如常用的Iterator
trait就是如此。它从以前的一个trait变成了如今的interator和iteratorExt.&lt;/p></description></item><item><title>Talk About Phantom Type</title><link>https://wooya.me/post/rust-phantom-type/</link><pubDate>Mon, 02 Nov 2015 10:36:23 +0800</pubDate><guid>https://wooya.me/post/rust-phantom-type/</guid><description>&lt;p>在具有高级类型系统的语言里面，有一种类型标记的用法叫phantom type,
比如&lt;a href="http://www.haskell.org/haskellwiki/Phantom_type" target="_blank" rel="noopener">Haskell语言&lt;/a>。这种用法有个很有意思用途：用来做编译时的类型检查，并且对于编译后的代码来说，完全没有任何的副作用。&lt;/p>
&lt;p>举个例子，在做几何运算的时候，我们会碰到运算时变量单位的问题。&lt;/p>
&lt;pre>&lt;code class="language-rust">#[deriving(Show)]
struct Length&amp;lt;Num&amp;gt;(Num);
type Meter = f64;
type Inch = f64;
let a: Length&amp;lt;Meter&amp;gt; = Length(5.0 as Meter);
let b: Length&amp;lt;Inch&amp;gt; = Length(7.0 as Inch);
impl&amp;lt;Num&amp;gt; Add&amp;lt;Length&amp;lt;Num&amp;gt;,Length&amp;lt;Num&amp;gt;&amp;gt; for Length&amp;lt;Num&amp;gt; where Num: Add&amp;lt;Num,Num&amp;gt; {
fn add(self, rhs: Length&amp;lt;Num&amp;gt;) -&amp;gt; Length&amp;lt;Num&amp;gt; {
Length(self.0 + rhs.0)
}
}
println!(&amp;quot;{}&amp;quot;, a + b);
&lt;/code>&lt;/pre>
&lt;p>在上面的代码中，我们有一个很明显的bug,单位为米的a竟然和单位为英寸的b进行了相加。要是在业务逻辑中出现这么一茬，肯定很难debug，因为从语法上来讲，完全没有问题啊！&lt;/p>
&lt;p>现在我们来引入一种类型系统的trick，叫做phantom type。&lt;/p>
&lt;pre>&lt;code class="language-rust">mod unit {
#[deriving(Show)]
enum Meter {}
#[deriving(Show)]
enum Inch {}
}
#[deriving(Show)]
struct Length&amp;lt;Unit,Num&amp;gt;(Num);
let a: Length&amp;lt;unit::Meter,f64&amp;gt; = Length(5.0);
let b: Length&amp;lt;unit::Inch,f64&amp;gt; = Length(7.0);
impl&amp;lt;Unit,Num&amp;gt; Add&amp;lt;Length&amp;lt;Unit,Num&amp;gt;,Length&amp;lt;Unit,Num&amp;gt;&amp;gt; for Length&amp;lt;Unit,Num&amp;gt; where Num: Add&amp;lt;Num,Num&amp;gt; {
fn add(self, rhs: Length&amp;lt;Unit,Num&amp;gt;) -&amp;gt; Length&amp;lt;Unit,Num&amp;gt; {
Length(self.0 + rhs.0)
}
}
println!(&amp;quot;{}&amp;quot;, a + b);
&lt;/code>&lt;/pre>
&lt;p>为了打印方便，加了一些&lt;code>#[deriving(Show)]&lt;/code>。 我们给Length类型加上了一个&lt;code>Unit &lt;/code>的类型标记。但是，Unit却没有出现在任何有值的地方，它仅仅是作为了一个类型标记存在着。所以，我想这也是为什么它叫&lt;code>phantom type&lt;/code>的原因吧。&lt;/p>
&lt;p>编译上面那段的代码，编译器会给你报错：&lt;/p>
&lt;pre>&lt;code class="language-rust">error: mismatched types: expected `main::Length&amp;lt;main::unit::Meter, f64&amp;gt;`, found `main::Length&amp;lt;main::unit::Inch,
f64&amp;gt;` (expected enum main::unit::Meter,found enum main::unit::Inch)
&lt;/code>&lt;/pre>
&lt;p>编译器说： a是&lt;code>Length&amp;lt;Meter,f64&amp;gt;&lt;/code>, b是&lt;code>&amp;lt;Inch，f64&amp;gt;&lt;/code>,它们类型不相容。&lt;/p>
&lt;p>仅仅通过增加一个额外的类型标记，我们就实现了让编译器自动给我们检查单位的方法，而且这种&lt;code>phantom type&lt;/code>的小trick，不会带来任何的运行时负担。在编译完毕后，它们就被一并的擦除了。&lt;/p>
&lt;p>其实这是一种对现实中单位制的模拟。平时我们写的时候一般写
1m，2mm之类。其实当我们写下了1m这个数字的时候，其实着我们写下了两个东西，作为数字的1和作为单位的m。单独拿出来，对于数字1来讲，他没有任何的意义。可以随便对他加上其它的数字；对于m来说，它仅仅是个单位，同样也没有意义。但是1m结合起来，m就为1赋予了class信息，改变了它的运算规则。&lt;code>phantom type&lt;/code>在此，就起到了这个量纲作用。&lt;/p>
&lt;p>除了用来作为数字的单位以外，还有一个比较好用的地方是作为用户输入安全性的标记（这和rust着重安全是遥相呼应啊）。
众所周知，web安全有很大一部分问题，是因为没有对用户输入做检查。一个安全的系统应该对于所有的用户输入采取不信任的态度，应该由代码对其进行检查。
但是在开发的时候，可能由于程序员水平问题，或者一时疏忽等原因，往往会忘记检查。这就为系统埋下了很大的隐患。
利用&lt;code>phantom type&lt;/code>我们可以为所有的string打上tag，让编译器来替我们进行检查。&lt;/p>
&lt;pre>&lt;code class="language-rust">enum Trusted {}
enum UnTrusted {}
struct UserInput&amp;lt;T&amp;gt;(String);
let a: UserInput&amp;lt;Trusted&amp;gt;(&amp;quot;safe&amp;quot;.to_string());
let b: UserInput&amp;lt;UnTrusted&amp;gt;(&amp;quot;SQL Injectiong is here!!!&amp;quot;.to_string());
insert_into_database(a);
insert_into_database(b); // 编译通不过
&lt;/code>&lt;/pre>
&lt;p>假定我们的&lt;code>insert_into_database&lt;/code>接受一个&lt;code>UserInput&amp;lt;Trusted&amp;gt;&lt;/code>作为输入。那么那个b，我们是无论如何也无法存入数据库的，必须要我们进行显式的检查，将其转换为UserInput&lt;Trusted>,否则编译必定报错。这样系统的安全性就大大的加强了。&lt;/p></description></item></channel></rss>